{"version":3,"file":"msal-node.esm.js","sources":["../src/utils/Constants.ts","../src/utils/NetworkUtils.ts","../src/network/HttpClient.ts","../src/config/Configuration.ts","../src/crypto/GuidGenerator.ts","../src/utils/EncodingUtils.ts","../src/crypto/HashUtils.ts","../src/crypto/PkceGenerator.ts","../src/crypto/CryptoProvider.ts","../src/cache/serializer/Deserializer.ts","../src/cache/serializer/Serializer.ts","../src/cache/NodeStorage.ts","../src/cache/TokenCache.ts","../src/packageMetadata.ts","../src/error/NodeAuthError.ts","../src/client/ClientApplication.ts","../src/network/LoopbackClient.ts","../src/client/PublicClientApplication.ts","../src/client/ClientAssertion.ts","../src/client/ConfidentialClientApplication.ts","../src/cache/distributed/DistributedCachePlugin.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * http methods\n */\nexport enum HttpMethod {\n    GET = \"get\",\n    POST = \"post\",\n}\n\nexport enum HttpStatus {\n    SUCCESS_RANGE_START = 200,\n    SUCCESS_RANGE_END = 299,\n    REDIRECT = 302,\n    CLIENT_ERROR_RANGE_START = 400,\n    CLIENT_ERROR_RANGE_END = 499,\n    SERVER_ERROR_RANGE_START = 500,\n    SERVER_ERROR_RANGE_END = 599\n}\n\nexport enum ProxyStatus {\n    SUCCESS_RANGE_START = 200,\n    SUCCESS_RANGE_END = 299,\n    SERVER_ERROR = 500\n}\n\n/**\n * Constants used for region discovery\n */\nexport const REGION_ENVIRONMENT_VARIABLE = \"REGION_NAME\";\n\n/**\n * Constant used for PKCE\n */\nexport const RANDOM_OCTET_SIZE = 32;\n\n/**\n * Constants used in PKCE\n */\nexport const Hash = {\n    SHA256: \"sha256\",\n};\n\n/**\n * Constants for encoding schemes\n */\nexport const CharSet = {\n    CV_CHARSET:\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~\",\n};\n\n/**\n * Cache Constants\n */\nexport const CACHE = {\n    FILE_CACHE: \"fileCache\",\n    EXTENSION_LIB: \"extenstion_library\",\n};\n\n/**\n * Constants\n */\nexport const Constants = {\n    MSAL_SKU: \"msal.js.node\",\n    JWT_BEARER_ASSERTION_TYPE: \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\",\n    AUTHORIZATION_PENDING: \"authorization_pending\",\n    HTTP_PROTOCOL: \"http://\",\n    LOCALHOST: \"localhost\"\n};\n\n/**\n * API Codes for Telemetry purposes.\n * Before adding a new code you must claim it in the MSAL Telemetry tracker as these number spaces are shared across all MSALs\n * 0-99 Silent Flow\n * 600-699 Device Code Flow\n * 800-899 Auth Code Flow\n */\nexport enum ApiId {\n    acquireTokenSilent = 62,\n    acquireTokenByUsernamePassword = 371,\n    acquireTokenByDeviceCode = 671,\n    acquireTokenByClientCredential = 771,\n    acquireTokenByCode = 871,\n    acquireTokenByRefreshToken = 872\n}\n\n/**\n * JWT  constants\n */\nexport const JwtConstants = {\n    ALGORITHM: \"alg\",\n    RSA_256: \"RS256\",\n    X5T: \"x5t\", \n    X5C: \"x5c\",\n    AUDIENCE: \"aud\",\n    EXPIRATION_TIME: \"exp\",\n    ISSUER: \"iss\",\n    SUBJECT: \"sub\",\n    NOT_BEFORE: \"nbf\",\n    JWT_ID: \"jti\",\n};\n\nexport const LOOPBACK_SERVER_CONSTANTS = {\n    INTERVAL_MS: 100,\n    TIMEOUT_MS: 5000\n};\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { NetworkResponse } from \"@azure/msal-common\";\n\nexport class NetworkUtils {\n    static getNetworkResponse<T>(headers: Record<string, string>, body: T, statusCode: number): NetworkResponse<T> {\n        return {\n            headers: headers,\n            body: body,\n            status: statusCode,\n        };\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { INetworkModule, NetworkRequestOptions, NetworkResponse } from \"@azure/msal-common\";\nimport { HttpMethod, Constants, HttpStatus, ProxyStatus } from \"../utils/Constants\";\nimport { NetworkUtils } from \"../utils/NetworkUtils\";\nimport http from \"http\";\nimport https from \"https\";\n\n/**\n * This class implements the API for network requests.\n */\nexport class HttpClient implements INetworkModule {\n    private proxyUrl: string;\n    private customAgentOptions: http.AgentOptions | https.AgentOptions;\n\n    constructor(\n        proxyUrl?: string,\n        customAgentOptions?: http.AgentOptions | https.AgentOptions,\n    ) {\n        this.proxyUrl = proxyUrl || \"\";\n        this.customAgentOptions = customAgentOptions || {};\n    }\n\n    /**\n     * Http Get request\n     * @param url\n     * @param options\n     */\n    async sendGetRequestAsync<T>(\n        url: string,\n        options?: NetworkRequestOptions,\n    ): Promise<NetworkResponse<T>> {\n        if (this.proxyUrl) {\n            return networkRequestViaProxy(url, this.proxyUrl, HttpMethod.GET, options, this.customAgentOptions as http.AgentOptions);\n        } else {\n            return networkRequestViaHttps(url, HttpMethod.GET, options, this.customAgentOptions as https.AgentOptions);\n        }\n    }\n\n    /**\n     * Http Post request\n     * @param url\n     * @param options\n     */\n    async sendPostRequestAsync<T>(\n        url: string,\n        options?: NetworkRequestOptions,\n        cancellationToken?: number,\n    ): Promise<NetworkResponse<T>> {\n        if (this.proxyUrl) {\n            return networkRequestViaProxy(url, this.proxyUrl, HttpMethod.POST, options, this.customAgentOptions as http.AgentOptions, cancellationToken);\n        } else {\n            return networkRequestViaHttps(url, HttpMethod.POST, options, this.customAgentOptions as https.AgentOptions, cancellationToken);\n        }\n    }\n}\n\nconst networkRequestViaProxy = <T>(\n    url: string,\n    proxyUrlString: string,\n    httpMethod: string,\n    options?: NetworkRequestOptions,\n    agentOptions?: http.AgentOptions,\n    timeout?: number,\n): Promise<NetworkResponse<T>> => {\n    const headers = options?.headers || {} as Record<string, string>;\n    const proxyUrl = new URL(proxyUrlString);\n    const destinationUrl = new URL(url);\n\n    // \"method: connect\" must be used to establish a connection to the proxy\n    const tunnelRequestOptions: https.RequestOptions = {\n        host: proxyUrl.hostname,\n        port: proxyUrl.port,\n        method: \"CONNECT\",\n        path: destinationUrl.hostname,\n        headers: headers,\n    };\n\n    if (timeout) {\n        tunnelRequestOptions.timeout = timeout;\n    }\n\n    if (agentOptions && Object.keys(agentOptions).length) {\n        tunnelRequestOptions.agent = new http.Agent(agentOptions);\n    }\n\n    // compose a request string for the socket\n    let postRequestStringContent: string = \"\";\n    if (httpMethod === HttpMethod.POST) {\n        const body = options?.body || \"\";\n        postRequestStringContent =\n            \"Content-Type: application/x-www-form-urlencoded\\r\\n\" +\n            `Content-Length: ${body.length}\\r\\n` +\n            `\\r\\n${body}`;\n    }\n    const outgoingRequestString = `${httpMethod.toUpperCase()} ${destinationUrl.href} HTTP/1.1\\r\\n` +\n        `Host: ${destinationUrl.host}\\r\\n` +\n        \"Connection: close\\r\\n\" +\n        postRequestStringContent +\n        \"\\r\\n\";\n\n    return new Promise<NetworkResponse<T>>(((resolve, reject) => {\n        const request = http.request(tunnelRequestOptions);\n\n        if (tunnelRequestOptions.timeout) {\n            request.on(\"timeout\", () => {\n                request.destroy();\n                reject(new Error(\"Request time out\"));\n            });\n        }\n\n        request.end();\n\n        // establish connection to the proxy\n        request.on(\"connect\", (response, socket) => {\n            const proxyStatusCode = response?.statusCode || ProxyStatus.SERVER_ERROR;\n            if ((proxyStatusCode < ProxyStatus.SUCCESS_RANGE_START) || (proxyStatusCode > ProxyStatus.SUCCESS_RANGE_END)) {\n                request.destroy();\n                socket.destroy();\n                reject(new Error(`Error connecting to proxy. Http status code: ${response.statusCode}. Http status message: ${response?.statusMessage || \"Unknown\"}`));\n            }\n            if (tunnelRequestOptions.timeout) {\n                socket.setTimeout(tunnelRequestOptions.timeout);\n                socket.on(\"timeout\", () => {\n                    request.destroy();\n                    socket.destroy();\n                    reject(new Error(\"Request time out\"));\n                });\n            }\n\n            // make a request over an HTTP tunnel\n            socket.write(outgoingRequestString);\n\n            const data: Buffer[] = [];\n            socket.on(\"data\", (chunk) => {\n                data.push(chunk);\n            });\n\n            socket.on(\"end\", () => {\n                // combine all received buffer streams into one buffer, and then into a string\n                const dataString = Buffer.concat([...data]).toString();\n\n                // separate each line into it's own entry in an arry\n                const dataStringArray = dataString.split(\"\\r\\n\");\n                // the first entry will contain the statusCode and statusMessage\n                const httpStatusCode = parseInt(dataStringArray[0].split(\" \")[1]);\n                // remove \"HTTP/1.1\" and the status code to get the status message\n                const statusMessage = dataStringArray[0].split(\" \").slice(2).join(\" \");\n                // the last entry will contain the body\n                const body = dataStringArray[dataStringArray.length - 1];\n\n                // everything in between the first and last entries are the headers\n                const headersArray = dataStringArray.slice(1, dataStringArray.length - 2);\n\n                // build an object out of all the headers\n                const entries = new Map();\n                headersArray.forEach((header) => {\n                    /**\n                     * the header might look like \"Content-Length: 1531\", but that is just a string\n                     * it needs to be converted to a key/value pair\n                     * split the string at the first instance of \":\"\n                     * there may be more than one \":\" if the value of the header is supposed to be a JSON object\n                     */\n                    const headerKeyValue = header.split(new RegExp(/:\\s(.*)/s));\n                    const headerKey = headerKeyValue[0];\n                    let headerValue = headerKeyValue[1];\n\n                    // check if the value of the header is supposed to be a JSON object\n                    try {\n                        const object = JSON.parse(headerValue);\n\n                        // if it is, then convert it from a string to a JSON object\n                        if (object && (typeof object === \"object\")) {\n                            headerValue = object;\n                        }\n                    } catch (e) {\n                        // otherwise, leave it as a string\n                    }\n\n                    entries.set(headerKey, headerValue);\n                });\n                const headers = Object.fromEntries(entries);\n\n                const parsedHeaders = headers as Record<string, string>;\n                const networkResponse = NetworkUtils.getNetworkResponse(\n                    parsedHeaders,\n                    parseBody(httpStatusCode, statusMessage, parsedHeaders, body) as T,\n                    httpStatusCode\n                );\n\n                if (((httpStatusCode < HttpStatus.SUCCESS_RANGE_START) || (httpStatusCode > HttpStatus.SUCCESS_RANGE_END)) &&\n                    // do not destroy the request for the device code flow\n                    networkResponse.body[\"error\"] !== Constants.AUTHORIZATION_PENDING) {\n                    request.destroy();\n                }\n                resolve(networkResponse);\n            });\n\n            socket.on(\"error\", (chunk) => {\n                request.destroy();\n                socket.destroy();\n                reject(new Error(chunk.toString()));\n            });\n        });\n\n        request.on(\"error\", (chunk) => {\n            request.destroy();\n            reject(new Error(chunk.toString()));\n        });\n    }));\n};\n\nconst networkRequestViaHttps = <T>(\n    url: string,\n    httpMethod: string,\n    options?: NetworkRequestOptions,\n    agentOptions?: https.AgentOptions,\n    timeout?: number,\n): Promise<NetworkResponse<T>> => {\n    const isPostRequest = httpMethod === HttpMethod.POST;\n    const body: string = options?.body || \"\";\n\n    const emptyHeaders: Record<string, string> = {};\n    const customOptions: https.RequestOptions = {\n        method: httpMethod,\n        headers: options?.headers || emptyHeaders,\n    };\n\n    if (timeout) {\n        customOptions.timeout = timeout;\n    }\n\n    if (agentOptions && Object.keys(agentOptions).length) {\n        customOptions.agent = new https.Agent(agentOptions);\n    }\n\n    if (isPostRequest) {\n        // needed for post request to work\n        customOptions.headers = {\n            ...customOptions.headers,\n            \"Content-Length\": body.length,\n        };\n    }\n\n    return new Promise<NetworkResponse<T>>((resolve, reject) => {\n        const request = https.request(url, customOptions);\n\n        if (timeout) {\n            request.on(\"timeout\", () => {\n                request.destroy();\n                reject(new Error(\"Request time out\"));\n            });\n        }\n\n        if (isPostRequest) {\n            request.write(body);\n        }\n\n        request.end();\n\n        request.on(\"response\", (response) => {\n            const headers = response.headers;\n            const statusCode = response.statusCode as number;\n            const statusMessage = response.statusMessage;\n\n            const data: Buffer[] = [];\n            response.on(\"data\", (chunk) => {\n                data.push(chunk);\n            });\n\n            response.on(\"end\", () => {\n                // combine all received buffer streams into one buffer, and then into a string\n                const body = Buffer.concat([...data]).toString();\n\n                const parsedHeaders = headers as Record<string, string>;\n                const networkResponse = NetworkUtils.getNetworkResponse(\n                    parsedHeaders,\n                    parseBody(statusCode, statusMessage, parsedHeaders, body) as T,\n                    statusCode\n                );\n\n                if (((statusCode < HttpStatus.SUCCESS_RANGE_START) || (statusCode > HttpStatus.SUCCESS_RANGE_END)) &&\n                    // do not destroy the request for the device code flow\n                    networkResponse.body[\"error\"] !== Constants.AUTHORIZATION_PENDING) {\n                    request.destroy();\n                }\n                resolve(networkResponse);\n            });\n        });\n\n        request.on(\"error\", (chunk) => {\n            request.destroy();\n            reject(new Error(chunk.toString()));\n        });\n    });\n};\n\n/**\n * Check if extra parsing is needed on the repsonse from the server\n * @param statusCode {number} the status code of the response from the server\n * @param statusMessage {string | undefined} the status message of the response from the server\n * @param headers {Record<string, string>} the headers of the response from the server\n * @param body {string} the body from the response of the server\n * @returns {Object} JSON parsed body or error object\n */\nconst parseBody = (statusCode: number, statusMessage: string | undefined, headers: Record<string, string>, body: string) => {\n    /*\n     * Informational responses (100 – 199)\n     * Successful responses (200 – 299)\n     * Redirection messages (300 – 399)\n     * Client error responses (400 – 499)\n     * Server error responses (500 – 599)\n     */\n    \n    let parsedBody;\n    try {\n        parsedBody = JSON.parse(body);\n    } catch (error) {\n        let errorType;\n        let errorDescriptionHelper;\n        if ((statusCode >= HttpStatus.CLIENT_ERROR_RANGE_START) && (statusCode <= HttpStatus.CLIENT_ERROR_RANGE_END)) {\n            errorType = \"client_error\";\n            errorDescriptionHelper = \"A client\";\n        } else if ((statusCode >= HttpStatus.SERVER_ERROR_RANGE_START) && (statusCode <= HttpStatus.SERVER_ERROR_RANGE_END)) {\n            errorType = \"server_error\";\n            errorDescriptionHelper = \"A server\";\n        } else {\n            errorType = \"unknown_error\";\n            errorDescriptionHelper = \"An unknown\";\n        }\n\n        parsedBody = {\n            error: errorType,\n            error_description: `${errorDescriptionHelper} error occured.\\nHttp status code: ${statusCode}\\nHttp status message: ${statusMessage || \"Unknown\"}\\nHeaders: ${JSON.stringify(headers)}`\n        };\n    }\n\n    return parsedBody;\n};\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    LoggerOptions,\n    INetworkModule,\n    LogLevel,\n    ProtocolMode,\n    ICachePlugin,\n    Constants,\n    AzureCloudInstance,\n    AzureCloudOptions,\n    ApplicationTelemetry\n} from \"@azure/msal-common\";\nimport { HttpClient } from \"../network/HttpClient\";\nimport { AgentOptions as httpAgentOptions } from \"http\";\nimport { AgentOptions as httpsAgentOptions } from \"https\";\n\n/**\n * - clientId               - Client id of the application.\n * - authority              - Url of the authority. If no value is set, defaults to https://login.microsoftonline.com/common.\n * - knownAuthorities       - Needed for Azure B2C and ADFS. All authorities that will be used in the client application. Only the host of the authority should be passed in.\n * - clientSecret           - Secret string that the application uses when requesting a token. Only used in confidential client applications. Can be created in the Azure app registration portal.\n * - clientAssertion        - Assertion string that the application uses when requesting a token. Only used in confidential client applications. Assertion should be of type urn:ietf:params:oauth:client-assertion-type:jwt-bearer.\n * - clientCertificate      - Certificate that the application uses when requesting a token. Only used in confidential client applications. Requires hex encoded X.509 SHA-1 thumbprint of the certificiate, and the PEM encoded private key (string should contain -----BEGIN PRIVATE KEY----- ... -----END PRIVATE KEY----- )\n * - protocolMode           - Enum that represents the protocol that msal follows. Used for configuring proper endpoints.\n * - skipAuthorityMetadataCache - A flag to choose whether to use or not use the local metadata cache during authority initialization. Defaults to false.\n * @public\n */\nexport type NodeAuthOptions = {\n    clientId: string;\n    authority?: string;\n    clientSecret?: string;\n    clientAssertion?: string;\n    clientCertificate?: {\n        thumbprint: string,\n        privateKey: string,\n        x5c?: string\n    };\n    knownAuthorities?: Array<string>;\n    cloudDiscoveryMetadata?: string;\n    authorityMetadata?: string;\n    clientCapabilities?: Array<string>;\n    protocolMode?: ProtocolMode;\n    azureCloudOptions?: AzureCloudOptions;\n    skipAuthorityMetadataCache?: boolean;\n};\n\n/**\n * Use this to configure the below cache configuration options:\n *\n * - cachePlugin   - Plugin for reading and writing token cache to disk.\n * @public\n */\nexport type CacheOptions = {\n    cachePlugin?: ICachePlugin;\n};\n\n/**\n * Type for configuring logger and http client options\n *\n * - logger                       - Used to initialize the Logger object; TODO: Expand on logger details or link to the documentation on logger\n * - networkClient                - Http client used for all http get and post calls. Defaults to using MSAL's default http client.\n * @public\n */\nexport type NodeSystemOptions = {\n    loggerOptions?: LoggerOptions;\n    networkClient?: INetworkModule;\n    proxyUrl?: string;\n    customAgentOptions?: httpAgentOptions | httpsAgentOptions;\n};\n\nexport type NodeTelemetryOptions = {\n    application?: ApplicationTelemetry;\n};\n\n/**\n * Use the configuration object to configure MSAL and initialize the client application object\n *\n * - auth: this is where you configure auth elements like clientID, authority used for authenticating against the Microsoft Identity Platform\n * - cache: this is where you configure cache location\n * - system: this is where you can configure the network client, logger\n * @public\n */\nexport type Configuration = {\n    auth: NodeAuthOptions;\n    cache?: CacheOptions;\n    system?: NodeSystemOptions;\n    telemetry?: NodeTelemetryOptions;\n};\n\nconst DEFAULT_AUTH_OPTIONS: Required<NodeAuthOptions> = {\n    clientId: Constants.EMPTY_STRING,\n    authority: Constants.DEFAULT_AUTHORITY,\n    clientSecret: Constants.EMPTY_STRING,\n    clientAssertion: Constants.EMPTY_STRING,\n    clientCertificate: {\n        thumbprint: Constants.EMPTY_STRING,\n        privateKey: Constants.EMPTY_STRING,\n        x5c: Constants.EMPTY_STRING\n    },\n    knownAuthorities: [],\n    cloudDiscoveryMetadata: Constants.EMPTY_STRING,\n    authorityMetadata: Constants.EMPTY_STRING,\n    clientCapabilities: [],\n    protocolMode: ProtocolMode.AAD,\n    azureCloudOptions: {\n        azureCloudInstance: AzureCloudInstance.None,\n        tenant: Constants.EMPTY_STRING\n    },\n    skipAuthorityMetadataCache: false,\n};\n\nconst DEFAULT_CACHE_OPTIONS: CacheOptions = {};\n\nconst DEFAULT_LOGGER_OPTIONS: LoggerOptions = {\n    loggerCallback: (): void => {\n        // allow users to not set logger call back \n    },\n    piiLoggingEnabled: false,\n    logLevel: LogLevel.Info,\n};\n\nconst DEFAULT_SYSTEM_OPTIONS: Required<NodeSystemOptions> = {\n    loggerOptions: DEFAULT_LOGGER_OPTIONS,\n    networkClient: new HttpClient(),\n    proxyUrl: Constants.EMPTY_STRING,\n    customAgentOptions: {} as httpAgentOptions | httpsAgentOptions,\n};\n\nconst DEFAULT_TELEMETRY_OPTIONS: Required<NodeTelemetryOptions> = {\n    application: {\n        appName: Constants.EMPTY_STRING,\n        appVersion: Constants.EMPTY_STRING\n    }\n};\n\nexport type NodeConfiguration = {\n    auth: Required<NodeAuthOptions>;\n    cache: CacheOptions;\n    system: Required<NodeSystemOptions>;\n    telemetry: Required<NodeTelemetryOptions>;\n};\n\n/**\n * Sets the default options when not explicitly configured from app developer\n *\n * @param auth - Authentication options\n * @param cache - Cache options\n * @param system - System options\n * @param telemetry - Telemetry options\n *\n * @returns Configuration\n * @public\n */\nexport function buildAppConfiguration({\n    auth,\n    cache,\n    system,\n    telemetry\n}: Configuration): NodeConfiguration {\n    const systemOptions: Required<NodeSystemOptions> = {\n        ...DEFAULT_SYSTEM_OPTIONS,\n        networkClient: new HttpClient(system?.proxyUrl, (system?.customAgentOptions as httpAgentOptions | httpsAgentOptions)),\n        loggerOptions: system?.loggerOptions || DEFAULT_LOGGER_OPTIONS,\n    };\n\n    return {\n        auth: { ...DEFAULT_AUTH_OPTIONS, ...auth },\n        cache: { ...DEFAULT_CACHE_OPTIONS, ...cache },\n        system: { ...systemOptions, ...system },\n        telemetry: { ...DEFAULT_TELEMETRY_OPTIONS, ...telemetry }\n    };\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { IGuidGenerator } from \"@azure/msal-common\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nexport class GuidGenerator implements IGuidGenerator {\n    /**\n     *\n     * RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or pseudo-random numbers.\n     * uuidv4 generates guids from cryprtographically-string random\n     */\n    generateGuid(): string {\n        return uuidv4();\n    }\n\n    /**\n     * verifies if a string is  GUID\n     * @param guid\n     */\n    isGuid(guid: string): boolean {\n        const regexGuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n        return regexGuid.test(guid);\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { Constants } from \"@azure/msal-common\";\n\nexport class EncodingUtils {\n    /**\n     * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.\n     * 'base64': Base64 encoding.\n     *\n     * @param str text\n     */\n    static base64Encode(str: string, encoding?: BufferEncoding): string {\n        return Buffer.from(str, encoding).toString(\"base64\");\n    }\n\n    /**\n     * encode a URL\n     * @param str\n     */\n    static base64EncodeUrl(str: string, encoding?: BufferEncoding): string {\n        return EncodingUtils.base64Encode(str, encoding)\n            .replace(/=/g, Constants.EMPTY_STRING)\n            .replace(/\\+/g, \"-\")\n            .replace(/\\//g, \"_\");\n    }\n\n    /**\n     * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.\n     * 'base64': Base64 encoding.\n     *\n     * @param base64Str Base64 encoded text\n     */\n    static base64Decode(base64Str: string): string {\n        return Buffer.from(base64Str, \"base64\").toString(\"utf8\");\n    }\n\n    /**\n     * @param base64Str Base64 encoded Url\n     */\n    static base64DecodeUrl(base64Str: string): string {\n        let str = base64Str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n        while (str.length % 4) {\n            str += \"=\";\n        }\n        return EncodingUtils.base64Decode(str);\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { Hash } from \"../utils/Constants\";\nimport crypto from \"crypto\";\n\nexport class HashUtils {\n    /**\n     * generate 'SHA256' hash\n     * @param buffer\n     */\n    sha256(buffer: string): Buffer {\n        return crypto\n            .createHash(Hash.SHA256)\n            .update(buffer)\n            .digest();\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { Constants, PkceCodes } from \"@azure/msal-common\";\nimport { CharSet, RANDOM_OCTET_SIZE } from \"../utils/Constants\";\nimport { EncodingUtils } from \"../utils/EncodingUtils\";\nimport { HashUtils } from \"./HashUtils\";\nimport crypto from \"crypto\";\n\n/**\n * https://tools.ietf.org/html/rfc7636#page-8\n */\nexport class PkceGenerator {\n    private hashUtils: HashUtils;\n\n    constructor() {\n        this.hashUtils = new HashUtils();\n    }\n    /**\n     * generates the codeVerfier and the challenge from the codeVerfier\n     * reference: https://tools.ietf.org/html/rfc7636#section-4.1 and https://tools.ietf.org/html/rfc7636#section-4.2\n     */\n    async generatePkceCodes(): Promise<PkceCodes> {\n        const verifier = this.generateCodeVerifier();\n        const challenge = this.generateCodeChallengeFromVerifier(verifier);\n        return { verifier, challenge };\n    }\n\n    /**\n     * generates the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.1\n     */\n    private generateCodeVerifier(): string {\n        const charArr = [];\n        const maxNumber = 256 - (256 % CharSet.CV_CHARSET.length);\n        while (charArr.length <= RANDOM_OCTET_SIZE) {\n            const byte = crypto.randomBytes(1)[0];\n            if (byte >= maxNumber) {\n                /* \n                 * Ignore this number to maintain randomness.\n                 * Including it would result in an unequal distribution of characters after doing the modulo\n                 */\n                continue;\n            }\n            const index = byte % CharSet.CV_CHARSET.length;\n            charArr.push(CharSet.CV_CHARSET[index]);\n        }\n        const verifier: string = charArr.join(Constants.EMPTY_STRING);\n        return EncodingUtils.base64EncodeUrl(verifier);\n    }\n\n    /**\n     * generate the challenge from the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.2\n     * @param codeVerifier\n     */\n    private generateCodeChallengeFromVerifier(codeVerifier: string): string {\n        return EncodingUtils.base64EncodeUrl(\n            this.hashUtils.sha256(codeVerifier).toString(\"base64\"), \n            \"base64\" \n        );\n    }\n\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { ICrypto, PkceCodes } from \"@azure/msal-common\";\nimport { GuidGenerator } from \"./GuidGenerator\";\nimport { EncodingUtils } from \"../utils/EncodingUtils\";\nimport { PkceGenerator } from \"./PkceGenerator\";\nimport { HashUtils } from \"./HashUtils\";\n\n/**\n * This class implements MSAL node's crypto interface, which allows it to perform base64 encoding and decoding, generating cryptographically random GUIDs and\n * implementing Proof Key for Code Exchange specs for the OAuth Authorization Code Flow using PKCE (rfc here: https://tools.ietf.org/html/rfc7636).\n * @public\n */\nexport class CryptoProvider implements ICrypto {\n    private pkceGenerator: PkceGenerator;\n    private guidGenerator: GuidGenerator;\n    private hashUtils: HashUtils;\n\n    constructor() {\n        // Browser crypto needs to be validated first before any other classes can be set.\n        this.pkceGenerator = new PkceGenerator();\n        this.guidGenerator = new GuidGenerator();\n        this.hashUtils = new HashUtils();\n    }\n\n    /**\n     * Creates a new random GUID - used to populate state and nonce.\n     * @returns string (GUID)\n     */\n    createNewGuid(): string {\n        return this.guidGenerator.generateGuid();\n    }\n\n    /**\n     * Encodes input string to base64.\n     * @param input - string to be encoded\n     */\n    base64Encode(input: string): string {\n        return EncodingUtils.base64Encode(input);\n    }\n\n    /**\n     * Decodes input string from base64.\n     * @param input - string to be decoded\n     */\n    base64Decode(input: string): string {\n        return EncodingUtils.base64Decode(input);\n    }\n\n    /**\n     * Generates PKCE codes used in Authorization Code Flow.\n     */\n    generatePkceCodes(): Promise<PkceCodes> {\n        return this.pkceGenerator.generatePkceCodes();\n    }\n\n    /**\n     * Generates a keypair, stores it and returns a thumbprint - not yet implemented for node\n     */\n    getPublicKeyThumbprint(): Promise<string> {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    /**\n     * Removes cryptographic keypair from key store matching the keyId passed in\n     * @param kid \n     */\n    removeTokenBindingKey(): Promise<boolean> {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    /**\n     * Removes all cryptographic keys from Keystore\n     */\n    clearKeystore(): Promise<boolean> {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    /**\n     * Signs the given object as a jwt payload with private key retrieved by given kid - currently not implemented for node\n     */\n    signJwt(): Promise<string> {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    /**\n     * Returns the SHA-256 hash of an input string\n     */\n    async hashString(plainText: string): Promise<string> {\n        return EncodingUtils.base64EncodeUrl(\n            this.hashUtils.sha256(plainText).toString(\"base64\"), \n            \"base64\" \n        );\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { StringUtils, AccountCache, IdTokenCache, AccessTokenCache, RefreshTokenCache, AppMetadataCache, AccountEntity, IdTokenEntity, AccessTokenEntity, RefreshTokenEntity, AppMetadataEntity, CacheManager } from \"@azure/msal-common\";\nimport { JsonCache, InMemoryCache, SerializedAccountEntity, SerializedIdTokenEntity, SerializedAccessTokenEntity, SerializedRefreshTokenEntity, SerializedAppMetadataEntity } from \"./SerializerTypes\";\n\n/**\n * This class deserializes cache entities read from the file into in memory object types defined internally\n */\nexport class Deserializer {\n    /**\n     * Parse the JSON blob in memory and deserialize the content\n     * @param cachedJson\n     */\n    static deserializeJSONBlob(jsonFile: string): JsonCache {\n        const deserializedCache = StringUtils.isEmpty(jsonFile)\n            ? {}\n            : JSON.parse(jsonFile);\n        return deserializedCache;\n    }\n\n    /**\n     * Deserializes accounts to AccountEntity objects\n     * @param accounts\n     */\n    static deserializeAccounts(accounts: Record<string, SerializedAccountEntity>): AccountCache {\n        const accountObjects: AccountCache = {};\n        if (accounts) {\n            Object.keys(accounts).map(function (key) {\n                const serializedAcc = accounts[key];\n                const mappedAcc = {\n                    homeAccountId: serializedAcc.home_account_id,\n                    environment: serializedAcc.environment,\n                    realm: serializedAcc.realm,\n                    localAccountId: serializedAcc.local_account_id,\n                    username: serializedAcc.username,\n                    authorityType: serializedAcc.authority_type,\n                    name: serializedAcc.name,\n                    clientInfo: serializedAcc.client_info,\n                    lastModificationTime: serializedAcc.last_modification_time,\n                    lastModificationApp: serializedAcc.last_modification_app,\n                };\n                const account: AccountEntity = new AccountEntity();\n                CacheManager.toObject(account, mappedAcc);\n                accountObjects[key] = account;\n            });\n        }\n\n        return accountObjects;\n    }\n\n    /**\n     * Deserializes id tokens to IdTokenEntity objects\n     * @param idTokens\n     */\n    static deserializeIdTokens(idTokens: Record<string, SerializedIdTokenEntity>): IdTokenCache {\n        const idObjects: IdTokenCache = {};\n        if (idTokens) {\n            Object.keys(idTokens).map(function (key) {\n                const serializedIdT = idTokens[key];\n                const mappedIdT = {\n                    homeAccountId: serializedIdT.home_account_id,\n                    environment: serializedIdT.environment,\n                    credentialType: serializedIdT.credential_type,\n                    clientId: serializedIdT.client_id,\n                    secret: serializedIdT.secret,\n                    realm: serializedIdT.realm,\n                };\n                const idToken: IdTokenEntity = new IdTokenEntity();\n                CacheManager.toObject(idToken, mappedIdT);\n                idObjects[key] = idToken;\n            });\n        }\n        return idObjects;\n    }\n\n    /**\n     * Deserializes access tokens to AccessTokenEntity objects\n     * @param accessTokens\n     */\n    static deserializeAccessTokens(accessTokens: Record<string, SerializedAccessTokenEntity>): AccessTokenCache {\n        const atObjects: AccessTokenCache = {};\n        if (accessTokens) {\n            Object.keys(accessTokens).map(function (key) {\n                const serializedAT = accessTokens[key];\n                const mappedAT = {\n                    homeAccountId: serializedAT.home_account_id,\n                    environment: serializedAT.environment,\n                    credentialType: serializedAT.credential_type,\n                    clientId: serializedAT.client_id,\n                    secret: serializedAT.secret,\n                    realm: serializedAT.realm,\n                    target: serializedAT.target,\n                    cachedAt: serializedAT.cached_at,\n                    expiresOn: serializedAT.expires_on,\n                    extendedExpiresOn: serializedAT.extended_expires_on,\n                    refreshOn: serializedAT.refresh_on,\n                    keyId: serializedAT.key_id,\n                    tokenType: serializedAT.token_type,\n                    requestedClaims: serializedAT.requestedClaims,\n                    requestedClaimsHash: serializedAT.requestedClaimsHash,\n                    userAssertionHash: serializedAT.userAssertionHash,\n                };\n                const accessToken: AccessTokenEntity = new AccessTokenEntity();\n                CacheManager.toObject(accessToken, mappedAT);\n                atObjects[key] = accessToken;\n            });\n        }\n\n        return atObjects;\n    }\n\n    /**\n     * Deserializes refresh tokens to RefreshTokenEntity objects\n     * @param refreshTokens\n     */\n    static deserializeRefreshTokens(refreshTokens: Record<string, SerializedRefreshTokenEntity>): RefreshTokenCache {\n        const rtObjects: RefreshTokenCache = {};\n        if (refreshTokens) {\n            Object.keys(refreshTokens).map(function (key) {\n                const serializedRT = refreshTokens[key];\n                const mappedRT = {\n                    homeAccountId: serializedRT.home_account_id,\n                    environment: serializedRT.environment,\n                    credentialType: serializedRT.credential_type,\n                    clientId: serializedRT.client_id,\n                    secret: serializedRT.secret,\n                    familyId: serializedRT.family_id,\n                    target: serializedRT.target,\n                    realm: serializedRT.realm,\n                };\n                const refreshToken: RefreshTokenEntity = new RefreshTokenEntity();\n                CacheManager.toObject(refreshToken, mappedRT);\n                rtObjects[key] = refreshToken;\n            });\n        }\n\n        return rtObjects;\n    }\n\n    /**\n     * Deserializes appMetadata to AppMetaData objects\n     * @param appMetadata\n     */\n    static deserializeAppMetadata(appMetadata: Record<string, SerializedAppMetadataEntity>): AppMetadataCache {\n        const appMetadataObjects: AppMetadataCache = {};\n        if (appMetadata) {\n            Object.keys(appMetadata).map(function (key) {\n                const serializedAmdt = appMetadata[key];\n                const mappedAmd = {\n                    clientId: serializedAmdt.client_id,\n                    environment: serializedAmdt.environment,\n                    familyId: serializedAmdt.family_id,\n                };\n                const amd: AppMetadataEntity = new AppMetadataEntity();\n                CacheManager.toObject(amd, mappedAmd);\n                appMetadataObjects[key] = amd;\n            });\n        }\n\n        return appMetadataObjects;\n    }\n\n    /**\n     * Deserialize an inMemory Cache\n     * @param jsonCache\n     */\n    static deserializeAllCache(jsonCache: JsonCache): InMemoryCache {\n        return {\n            accounts: jsonCache.Account\n                ? this.deserializeAccounts(jsonCache.Account)\n                : {},\n            idTokens: jsonCache.IdToken\n                ? this.deserializeIdTokens(jsonCache.IdToken)\n                : {},\n            accessTokens: jsonCache.AccessToken\n                ? this.deserializeAccessTokens(jsonCache.AccessToken)\n                : {},\n            refreshTokens: jsonCache.RefreshToken\n                ? this.deserializeRefreshTokens(jsonCache.RefreshToken)\n                : {},\n            appMetadata: jsonCache.AppMetadata\n                ? this.deserializeAppMetadata(jsonCache.AppMetadata)\n                : {},\n        };\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { AccountCache, IdTokenCache, AccessTokenCache, RefreshTokenCache, AppMetadataCache } from \"@azure/msal-common\";\nimport { InMemoryCache, JsonCache, SerializedAccountEntity, SerializedIdTokenEntity, SerializedAccessTokenEntity, SerializedRefreshTokenEntity, SerializedAppMetadataEntity } from \"./SerializerTypes\";\n\nexport class Serializer {\n    /**\n     * serialize the JSON blob\n     * @param data\n     */\n    static serializeJSONBlob(data: JsonCache): string {\n        return JSON.stringify(data);\n    }\n\n    /**\n     * Serialize Accounts\n     * @param accCache\n     */\n    static serializeAccounts(accCache: AccountCache): Record<string, SerializedAccountEntity> {\n        const accounts: Record<string, SerializedAccountEntity> = {};\n        Object.keys(accCache).map(function (key) {\n            const accountEntity = accCache[key];\n            accounts[key] = {\n                home_account_id: accountEntity.homeAccountId,\n                environment: accountEntity.environment,\n                realm: accountEntity.realm,\n                local_account_id: accountEntity.localAccountId,\n                username: accountEntity.username,\n                authority_type: accountEntity.authorityType,\n                name: accountEntity.name,\n                client_info: accountEntity.clientInfo,\n                last_modification_time: accountEntity.lastModificationTime,\n                last_modification_app: accountEntity.lastModificationApp,\n            };\n        });\n\n        return accounts;\n    }\n\n    /**\n     * Serialize IdTokens\n     * @param idTCache\n     */\n    static serializeIdTokens(idTCache: IdTokenCache): Record<string, SerializedIdTokenEntity> {\n        const idTokens: Record<string, SerializedIdTokenEntity> = {};\n        Object.keys(idTCache).map(function (key) {\n            const idTEntity = idTCache[key];\n            idTokens[key] = {\n                home_account_id: idTEntity.homeAccountId,\n                environment: idTEntity.environment,\n                credential_type: idTEntity.credentialType,\n                client_id: idTEntity.clientId,\n                secret: idTEntity.secret,\n                realm: idTEntity.realm,\n            };\n        });\n\n        return idTokens;\n    }\n\n    /**\n     * Serializes AccessTokens\n     * @param atCache\n     */\n    static serializeAccessTokens(atCache: AccessTokenCache): Record<string, SerializedAccessTokenEntity> {\n        const accessTokens: Record<string, SerializedAccessTokenEntity> = {};\n        Object.keys(atCache).map(function (key) {\n            const atEntity = atCache[key];\n            accessTokens[key] = {\n                home_account_id: atEntity.homeAccountId,\n                environment: atEntity.environment,\n                credential_type: atEntity.credentialType,\n                client_id: atEntity.clientId,\n                secret: atEntity.secret,\n                realm: atEntity.realm,\n                target: atEntity.target,\n                cached_at: atEntity.cachedAt,\n                expires_on: atEntity.expiresOn,\n                extended_expires_on: atEntity.extendedExpiresOn,\n                refresh_on: atEntity.refreshOn,\n                key_id: atEntity.keyId,\n                token_type: atEntity.tokenType,\n                requestedClaims: atEntity.requestedClaims,\n                requestedClaimsHash: atEntity.requestedClaimsHash,\n                userAssertionHash: atEntity.userAssertionHash\n            };\n        });\n\n        return accessTokens;\n    }\n\n    /**\n     * Serialize refreshTokens\n     * @param rtCache\n     */\n    static serializeRefreshTokens(rtCache: RefreshTokenCache): Record<string, SerializedRefreshTokenEntity> {\n        const refreshTokens: Record<string, SerializedRefreshTokenEntity> = {};\n        Object.keys(rtCache).map(function (key) {\n            const rtEntity = rtCache[key];\n            refreshTokens[key] = {\n                home_account_id: rtEntity.homeAccountId,\n                environment: rtEntity.environment,\n                credential_type: rtEntity.credentialType,\n                client_id: rtEntity.clientId,\n                secret: rtEntity.secret,\n                family_id: rtEntity.familyId,\n                target: rtEntity.target,\n                realm: rtEntity.realm\n            };\n        });\n\n        return refreshTokens;\n    }\n\n    /**\n     * Serialize amdtCache\n     * @param amdtCache\n     */\n    static serializeAppMetadata(amdtCache: AppMetadataCache): Record<string, SerializedAppMetadataEntity> {\n        const appMetadata: Record<string, SerializedAppMetadataEntity> = {};\n        Object.keys(amdtCache).map(function (key) {\n            const amdtEntity = amdtCache[key];\n            appMetadata[key] = {\n                client_id: amdtEntity.clientId,\n                environment: amdtEntity.environment,\n                family_id: amdtEntity.familyId,\n            };\n        });\n\n        return appMetadata;\n    }\n\n    /**\n     * Serialize the cache\n     * @param jsonContent\n     */\n    static serializeAllCache(inMemCache: InMemoryCache): JsonCache {\n        return {\n            Account: this.serializeAccounts(inMemCache.accounts),\n            IdToken: this.serializeIdTokens(inMemCache.idTokens),\n            AccessToken: this.serializeAccessTokens(inMemCache.accessTokens),\n            RefreshToken: this.serializeRefreshTokens(inMemCache.refreshTokens),\n            AppMetadata: this.serializeAppMetadata(inMemCache.appMetadata),\n        };\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AccountEntity,\n    IdTokenEntity,\n    AccessTokenEntity,\n    RefreshTokenEntity,\n    AppMetadataEntity,\n    ServerTelemetryEntity,\n    ThrottlingEntity,\n    CacheManager,\n    Logger,\n    ValidCacheType,\n    ICrypto,\n    AuthorityMetadataEntity,\n    ValidCredentialType\n} from \"@azure/msal-common\";\nimport { Deserializer } from \"./serializer/Deserializer\";\nimport { Serializer } from \"./serializer/Serializer\";\nimport { InMemoryCache, JsonCache, CacheKVStore } from \"./serializer/SerializerTypes\";\n\n/**\n * This class implements Storage for node, reading cache from user specified storage location or an  extension library\n * @public\n */\nexport class NodeStorage extends CacheManager {\n    // Cache configuration, either set by user or default values.\n    private logger: Logger;\n    private cache: CacheKVStore = {};\n    private changeEmitters: Array<Function> = [];\n\n    constructor(logger: Logger, clientId: string, cryptoImpl: ICrypto) {\n        super(clientId, cryptoImpl);\n        this.logger = logger;\n    }\n\n    /**\n     * Queue up callbacks\n     * @param func - a callback function for cache change indication\n     */\n    registerChangeEmitter(func: () => void): void {\n        this.changeEmitters.push(func);\n    }\n\n    /**\n     * Invoke the callback when cache changes\n     */\n    emitChange(): void {\n        this.changeEmitters.forEach(func => func.call(null));\n    }\n\n    /**\n     * Converts cacheKVStore to InMemoryCache\n     * @param cache - key value store\n     */\n    cacheToInMemoryCache(cache: CacheKVStore): InMemoryCache {\n        const inMemoryCache: InMemoryCache = {\n            accounts: {},\n            idTokens: {},\n            accessTokens: {},\n            refreshTokens: {},\n            appMetadata: {},\n        };\n\n        for (const key in cache) {\n            if (cache[key as string] instanceof AccountEntity) {\n                inMemoryCache.accounts[key] = cache[key] as AccountEntity;\n            } else if (cache[key] instanceof IdTokenEntity) {\n                inMemoryCache.idTokens[key] = cache[key] as IdTokenEntity;\n            } else if (cache[key] instanceof AccessTokenEntity) {\n                inMemoryCache.accessTokens[key] = cache[key] as AccessTokenEntity;\n            } else if (cache[key] instanceof RefreshTokenEntity) {\n                inMemoryCache.refreshTokens[key] = cache[key] as RefreshTokenEntity;\n            } else if (cache[key] instanceof AppMetadataEntity) {\n                inMemoryCache.appMetadata[key] = cache[key] as AppMetadataEntity;\n            } else {\n                continue;\n            }\n        }\n\n        return inMemoryCache;\n    }\n\n    /**\n     * converts inMemoryCache to CacheKVStore\n     * @param inMemoryCache - kvstore map for inmemory\n     */\n    inMemoryCacheToCache(inMemoryCache: InMemoryCache): CacheKVStore {\n\n        // convert in memory cache to a flat Key-Value map\n        let cache = this.getCache();\n\n        cache = {\n            ...cache,\n            ...inMemoryCache.accounts,\n            ...inMemoryCache.idTokens,\n            ...inMemoryCache.accessTokens,\n            ...inMemoryCache.refreshTokens,\n            ...inMemoryCache.appMetadata\n        };\n\n        // convert in memory cache to a flat Key-Value map\n        return cache;\n    }\n\n    /**\n     * gets the current in memory cache for the client\n     */\n    getInMemoryCache(): InMemoryCache {\n        this.logger.trace(\"Getting in-memory cache\");\n\n        // convert the cache key value store to inMemoryCache\n        const inMemoryCache = this.cacheToInMemoryCache(this.getCache());\n        return inMemoryCache;\n    }\n\n    /**\n     * sets the current in memory cache for the client\n     * @param inMemoryCache - key value map in memory\n     */\n    setInMemoryCache(inMemoryCache: InMemoryCache): void{\n        this.logger.trace(\"Setting in-memory cache\");\n\n        // convert and append the inMemoryCache to cacheKVStore\n        const cache = this.inMemoryCacheToCache(inMemoryCache);\n        this.setCache(cache);\n\n        this.emitChange();\n    }\n\n    /**\n     * get the current cache key-value store\n     */\n    getCache(): CacheKVStore {\n        this.logger.trace(\"Getting cache key-value store\");\n        return this.cache;\n    }\n\n    /**\n     * sets the current cache (key value store)\n     * @param cacheMap - key value map\n     */\n    setCache(cache: CacheKVStore): void {\n        this.logger.trace(\"Setting cache key value store\");\n        this.cache = cache;\n\n        // mark change in cache\n        this.emitChange();\n    }\n\n    /**\n     * Gets cache item with given key.\n     * @param key - lookup key for the cache entry\n     */\n    getItem(key: string): ValidCacheType {\n        this.logger.tracePii(`Item key: ${key}`);\n\n        // read cache\n        const cache = this.getCache();\n        return cache[key];\n    }\n\n    /**\n     * Gets cache item with given key-value\n     * @param key - lookup key for the cache entry\n     * @param value - value of the cache entry\n     */\n    setItem(key: string, value: ValidCacheType): void {\n        this.logger.tracePii(`Item key: ${key}`);\n\n        // read cache\n        const cache = this.getCache();\n        cache[key] = value;\n\n        // write to cache\n        this.setCache(cache);\n    }\n\n    /**\n     * fetch the account entity\n     * @param accountKey - lookup key to fetch cache type AccountEntity\n     */\n    getAccount(accountKey: string): AccountEntity | null {\n        const account = this.getItem(accountKey) as AccountEntity;\n        if (AccountEntity.isAccountEntity(account)) {\n            return account;\n        }\n        return null;\n    }\n\n    /**\n     * set account entity\n     * @param account - cache value to be set of type AccountEntity\n     */\n    setAccount(account: AccountEntity): void {\n        const accountKey = account.generateAccountKey();\n        this.setItem(accountKey, account);\n    }\n\n    /**\n     * fetch the idToken credential\n     * @param idTokenKey - lookup key to fetch cache type IdTokenEntity\n     */\n    getIdTokenCredential(idTokenKey: string): IdTokenEntity | null {\n        const idToken = this.getItem(idTokenKey) as IdTokenEntity;\n        if (IdTokenEntity.isIdTokenEntity(idToken)) {\n            return idToken;\n        }\n        return null;\n    }\n\n    /**\n     * set idToken credential\n     * @param idToken - cache value to be set of type IdTokenEntity\n     */\n    setIdTokenCredential(idToken: IdTokenEntity): void {\n        const idTokenKey = idToken.generateCredentialKey();\n        this.setItem(idTokenKey, idToken);\n    }\n\n    /**\n     * fetch the accessToken credential\n     * @param accessTokenKey - lookup key to fetch cache type AccessTokenEntity\n     */\n    getAccessTokenCredential(accessTokenKey: string): AccessTokenEntity | null {\n        const accessToken = this.getItem(accessTokenKey) as AccessTokenEntity;\n        if (AccessTokenEntity.isAccessTokenEntity(accessToken)) {\n            return accessToken;\n        }\n        return null;\n    }\n\n    /**\n     * set accessToken credential\n     * @param accessToken -  cache value to be set of type AccessTokenEntity\n     */\n    setAccessTokenCredential(accessToken: AccessTokenEntity): void {\n        const accessTokenKey = accessToken.generateCredentialKey();\n        this.setItem(accessTokenKey, accessToken);\n    }\n\n    /**\n     * fetch the refreshToken credential\n     * @param refreshTokenKey - lookup key to fetch cache type RefreshTokenEntity\n     */\n    getRefreshTokenCredential(refreshTokenKey: string): RefreshTokenEntity | null {\n        const refreshToken = this.getItem(refreshTokenKey) as RefreshTokenEntity;\n        if (RefreshTokenEntity.isRefreshTokenEntity(refreshToken)) {\n            return refreshToken as RefreshTokenEntity;\n        }\n        return null;\n    }\n\n    /**\n     * set refreshToken credential\n     * @param refreshToken - cache value to be set of type RefreshTokenEntity\n     */\n    setRefreshTokenCredential(refreshToken: RefreshTokenEntity): void {\n        const refreshTokenKey = refreshToken.generateCredentialKey();\n        this.setItem(refreshTokenKey, refreshToken);\n    }\n\n    /**\n     * fetch appMetadata entity from the platform cache\n     * @param appMetadataKey - lookup key to fetch cache type AppMetadataEntity\n     */\n    getAppMetadata(appMetadataKey: string): AppMetadataEntity | null {\n        const appMetadata: AppMetadataEntity = this.getItem(appMetadataKey) as AppMetadataEntity;\n        if (AppMetadataEntity.isAppMetadataEntity(appMetadataKey, appMetadata)) {\n            return appMetadata;\n        }\n        return null;\n    }\n\n    /**\n     * set appMetadata entity to the platform cache\n     * @param appMetadata - cache value to be set of type AppMetadataEntity\n     */\n    setAppMetadata(appMetadata: AppMetadataEntity): void {\n        const appMetadataKey = appMetadata.generateAppMetadataKey();\n        this.setItem(appMetadataKey, appMetadata);\n    }\n\n    /**\n     * fetch server telemetry entity from the platform cache\n     * @param serverTelemetrykey - lookup key to fetch cache type ServerTelemetryEntity\n     */\n    getServerTelemetry(serverTelemetrykey: string): ServerTelemetryEntity | null {\n        const serverTelemetryEntity: ServerTelemetryEntity = this.getItem(serverTelemetrykey) as ServerTelemetryEntity;\n        if (serverTelemetryEntity && ServerTelemetryEntity.isServerTelemetryEntity(serverTelemetrykey, serverTelemetryEntity)) {\n            return serverTelemetryEntity;\n        }\n        return null;\n    }\n\n    /**\n     * set server telemetry entity to the platform cache\n     * @param serverTelemetryKey - lookup key to fetch cache type ServerTelemetryEntity\n     * @param serverTelemetry - cache value to be set of type ServerTelemetryEntity\n     */\n    setServerTelemetry(serverTelemetryKey: string, serverTelemetry: ServerTelemetryEntity): void {\n        this.setItem(serverTelemetryKey, serverTelemetry);\n    }\n\n    /**\n     * fetch authority metadata entity from the platform cache\n     * @param key - lookup key to fetch cache type AuthorityMetadataEntity\n     */\n    getAuthorityMetadata(key: string): AuthorityMetadataEntity | null {\n        const authorityMetadataEntity: AuthorityMetadataEntity = this.getItem(key) as AuthorityMetadataEntity;\n        if (authorityMetadataEntity && AuthorityMetadataEntity.isAuthorityMetadataEntity(key, authorityMetadataEntity)) {\n            return authorityMetadataEntity;\n        }\n        return null;\n    }\n\n    /**\n     * Get all authority metadata keys\n     */\n    getAuthorityMetadataKeys(): Array<string> {\n        return this.getKeys().filter((key) => {\n            return this.isAuthorityMetadata(key);\n        });\n    }\n\n    /**\n     * set authority metadata entity to the platform cache\n     * @param key - lookup key to fetch cache type AuthorityMetadataEntity\n     * @param metadata - cache value to be set of type AuthorityMetadataEntity\n     */\n    setAuthorityMetadata(key: string, metadata: AuthorityMetadataEntity): void {\n        this.setItem(key, metadata);\n    }\n\n    /**\n     * fetch throttling entity from the platform cache\n     * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity\n     */\n    getThrottlingCache(throttlingCacheKey: string): ThrottlingEntity | null {\n        const throttlingCache: ThrottlingEntity = this.getItem(throttlingCacheKey) as ThrottlingEntity;\n        if (throttlingCache && ThrottlingEntity.isThrottlingEntity(throttlingCacheKey, throttlingCache)) {\n            return throttlingCache;\n        }\n        return null;\n    }\n\n    /**\n     * set throttling entity to the platform cache\n     * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity\n     * @param throttlingCache - cache value to be set of type ThrottlingEntity\n     */\n    setThrottlingCache(throttlingCacheKey: string, throttlingCache: ThrottlingEntity): void {\n        this.setItem(throttlingCacheKey, throttlingCache);\n    }\n\n    /**\n     * Removes the cache item from memory with the given key.\n     * @param key - lookup key to remove a cache entity\n     * @param inMemory - key value map of the cache\n     */\n    removeItem(key: string): boolean {\n        this.logger.tracePii(`Item key: ${key}`);\n\n        // read inMemoryCache\n        let result: boolean = false;\n        const cache = this.getCache();\n\n        if (!!cache[key]) {\n            delete cache[key];\n            result = true;\n        }\n\n        // write to the cache after removal\n        if (result) {\n            this.setCache(cache);\n            this.emitChange();\n        }\n        return result;\n    }\n\n    /**\n     * Checks whether key is in cache.\n     * @param key - look up key for a cache entity\n     */\n    containsKey(key: string): boolean {\n        return this.getKeys().includes(key);\n    }\n\n    /**\n     * Gets all keys in window.\n     */\n    getKeys(): string[] {\n        this.logger.trace(\"Retrieving all cache keys\");\n\n        // read cache\n        const cache = this.getCache();\n        return [ ...Object.keys(cache)];\n    }\n\n    /**\n     * Clears all cache entries created by MSAL (except tokens).\n     */\n    async clear(): Promise<void> {\n        this.logger.trace(\"Clearing cache entries created by MSAL\");\n\n        // read inMemoryCache\n        const cacheKeys = this.getKeys();\n\n        // delete each element\n        cacheKeys.forEach(key => {\n            this.removeItem(key);\n        });\n        this.emitChange();\n    }\n\n    /**\n     * Initialize in memory cache from an exisiting cache vault\n     * @param cache - blob formatted cache (JSON)\n     */\n    static generateInMemoryCache(cache: string): InMemoryCache {\n        return Deserializer.deserializeAllCache(\n            Deserializer.deserializeJSONBlob(cache)\n        );\n    }\n\n    /**\n     * retrieves the final JSON\n     * @param inMemoryCache - itemised cache read from the JSON\n     */\n    static generateJsonCache(inMemoryCache: InMemoryCache): JsonCache {\n        return Serializer.serializeAllCache(inMemoryCache);\n    }\n\n    /**\n     * Updates a credential's cache key if the current cache key is outdated\n     */\n    updateCredentialCacheKey(currentCacheKey: string, credential: ValidCredentialType): string {\n        const updatedCacheKey = credential.generateCredentialKey();\n\n        if (currentCacheKey !== updatedCacheKey) {\n            const cacheItem = this.getItem(currentCacheKey);\n            if (cacheItem) {\n                this.removeItem(currentCacheKey);\n                this.setItem(updatedCacheKey, cacheItem);\n                this.logger.verbose(`Updated an outdated ${credential.credentialType} cache key`);\n                return updatedCacheKey;\n            } else {\n                this.logger.error(`Attempted to update an outdated ${credential.credentialType} cache key but no item matching the outdated key was found in storage`);\n            }\n        }\n\n        return currentCacheKey;\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { NodeStorage } from \"./NodeStorage\";\nimport { StringUtils, AccountEntity, AccountInfo, Logger, ISerializableTokenCache, ICachePlugin, TokenCacheContext } from \"@azure/msal-common\";\nimport { InMemoryCache, JsonCache, SerializedAccountEntity, SerializedAccessTokenEntity, SerializedRefreshTokenEntity, SerializedIdTokenEntity, SerializedAppMetadataEntity, CacheKVStore } from \"./serializer/SerializerTypes\";\nimport { Deserializer } from \"./serializer/Deserializer\";\nimport { Serializer } from \"./serializer/Serializer\";\nimport { ITokenCache } from \"./ITokenCache\";\n\nconst defaultSerializedCache: JsonCache = {\n    Account: {},\n    IdToken: {},\n    AccessToken: {},\n    RefreshToken: {},\n    AppMetadata: {},\n};\n\n/**\n * In-memory token cache manager\n * @public\n */\nexport class TokenCache implements ISerializableTokenCache, ITokenCache {\n\n    private storage: NodeStorage;\n    private cacheHasChanged: boolean;\n    private cacheSnapshot: string;\n    private readonly persistence: ICachePlugin;\n    private logger: Logger;\n\n    constructor(storage: NodeStorage, logger: Logger, cachePlugin?: ICachePlugin) {\n        this.cacheHasChanged = false;\n        this.storage = storage;\n        this.storage.registerChangeEmitter(this.handleChangeEvent.bind(this));\n        if (cachePlugin) {\n            this.persistence = cachePlugin;\n        }\n        this.logger = logger;\n    }\n\n    /**\n     * Set to true if cache state has changed since last time serialize or writeToPersistence was called\n     */\n    hasChanged(): boolean {\n        return this.cacheHasChanged;\n    }\n\n    /**\n     * Serializes in memory cache to JSON\n     */\n    serialize(): string {\n        this.logger.trace(\"Serializing in-memory cache\");\n        let finalState = Serializer.serializeAllCache(\n            this.storage.getInMemoryCache() as InMemoryCache\n        );\n\n        // if cacheSnapshot not null or empty, merge\n        if (!StringUtils.isEmpty(this.cacheSnapshot)) {\n            this.logger.trace(\"Reading cache snapshot from disk\");\n            finalState = this.mergeState(\n                JSON.parse(this.cacheSnapshot),\n                finalState\n            );\n        } else {\n            this.logger.trace(\"No cache snapshot to merge\");\n        }\n        this.cacheHasChanged = false;\n\n        return JSON.stringify(finalState);\n    }\n\n    /**\n     * Deserializes JSON to in-memory cache. JSON should be in MSAL cache schema format\n     * @param cache - blob formatted cache\n     */\n    deserialize(cache: string): void {\n        this.logger.trace(\"Deserializing JSON to in-memory cache\");\n        this.cacheSnapshot = cache;\n\n        if (!StringUtils.isEmpty(this.cacheSnapshot)) {\n            this.logger.trace(\"Reading cache snapshot from disk\");\n            const deserializedCache = Deserializer.deserializeAllCache(\n                this.overlayDefaults(JSON.parse(this.cacheSnapshot))\n            );\n            this.storage.setInMemoryCache(deserializedCache);\n        } else {\n            this.logger.trace(\"No cache snapshot to deserialize\");\n        }\n    }\n\n    /**\n     * Fetches the cache key-value map\n     */\n    getKVStore(): CacheKVStore {\n        return this.storage.getCache();\n    }\n\n    /**\n     * API that retrieves all accounts currently in cache to the user\n     */\n    async getAllAccounts(): Promise<AccountInfo[]> {\n\n        this.logger.trace(\"getAllAccounts called\");\n        let cacheContext;\n        try {\n            if (this.persistence) {\n                cacheContext = new TokenCacheContext(this, false);\n                await this.persistence.beforeCacheAccess(cacheContext);\n            }\n            return this.storage.getAllAccounts();\n        } finally {\n            if (this.persistence && cacheContext) {\n                await this.persistence.afterCacheAccess(cacheContext);\n            }\n        }\n    }\n\n    /**\n     * Returns the signed in account matching homeAccountId.\n     * (the account object is created at the time of successful login)\n     * or null when no matching account is found\n     * @param homeAccountId - unique identifier for an account (uid.utid)\n     */\n    async getAccountByHomeId(homeAccountId: string): Promise<AccountInfo | null> {\n        const allAccounts = await this.getAllAccounts();\n        if (!StringUtils.isEmpty(homeAccountId) && allAccounts && allAccounts.length) {\n            return allAccounts.filter(accountObj => accountObj.homeAccountId === homeAccountId)[0] || null;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the signed in account matching localAccountId.\n     * (the account object is created at the time of successful login)\n     * or null when no matching account is found\n     * @param localAccountId - unique identifier of an account (sub/obj when homeAccountId cannot be populated)\n     */\n    async getAccountByLocalId(localAccountId: string): Promise<AccountInfo | null> {\n        const allAccounts = await this.getAllAccounts();\n        if (!StringUtils.isEmpty(localAccountId) && allAccounts && allAccounts.length) {\n            return allAccounts.filter(accountObj => accountObj.localAccountId === localAccountId)[0] || null;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * API to remove a specific account and the relevant data from cache\n     * @param account - AccountInfo passed by the user\n     */\n    async removeAccount(account: AccountInfo): Promise<void> {\n        this.logger.trace(\"removeAccount called\");\n        let cacheContext;\n        try {\n            if (this.persistence) {\n                cacheContext = new TokenCacheContext(this, true);\n                await this.persistence.beforeCacheAccess(cacheContext);\n            }\n            await this.storage.removeAccount(AccountEntity.generateAccountCacheKey(account));\n        } finally {\n            if (this.persistence && cacheContext) {\n                await this.persistence.afterCacheAccess(cacheContext);\n            }\n        }\n    }\n\n    /**\n     * Called when the cache has changed state.\n     */\n    private handleChangeEvent() {\n        this.cacheHasChanged = true;\n    }\n\n    /**\n     * Merge in memory cache with the cache snapshot.\n     * @param oldState - cache before changes\n     * @param currentState - current cache state in the library\n     */\n    private mergeState(oldState: JsonCache, currentState: JsonCache): JsonCache {\n        this.logger.trace(\"Merging in-memory cache with cache snapshot\");\n        const stateAfterRemoval = this.mergeRemovals(oldState, currentState);\n        return this.mergeUpdates(stateAfterRemoval, currentState);\n    }\n\n    /**\n     * Deep update of oldState based on newState values\n     * @param oldState - cache before changes\n     * @param newState - updated cache\n     */\n    private mergeUpdates(oldState: object, newState: object): JsonCache {\n        Object.keys(newState).forEach((newKey: string) => {\n            const newValue = newState[newKey];\n\n            // if oldState does not contain value but newValue does, add it\n            if (!oldState.hasOwnProperty(newKey)) {\n                if (newValue !== null) {\n                    oldState[newKey] = newValue;\n                }\n            } else {\n                // both oldState and newState contain the key, do deep update\n                const newValueNotNull = newValue !== null;\n                const newValueIsObject = typeof newValue === \"object\";\n                const newValueIsNotArray = !Array.isArray(newValue);\n                const oldStateNotUndefinedOrNull = typeof oldState[newKey] !== \"undefined\" && oldState[newKey] !== null;\n\n                if (newValueNotNull && newValueIsObject && newValueIsNotArray && oldStateNotUndefinedOrNull) {\n                    this.mergeUpdates(oldState[newKey], newValue);\n                } else {\n                    oldState[newKey] = newValue;\n                }\n            }\n        });\n\n        return oldState as JsonCache;\n    }\n\n    /**\n     * Removes entities in oldState that the were removed from newState. If there are any unknown values in root of\n     * oldState that are not recognized, they are left untouched.\n     * @param oldState - cache before changes\n     * @param newState - updated cache\n     */\n    private mergeRemovals(oldState: JsonCache, newState: JsonCache): JsonCache {\n        this.logger.trace(\"Remove updated entries in cache\");\n        const accounts = oldState.Account ? this.mergeRemovalsDict<SerializedAccountEntity>(oldState.Account, newState.Account) : oldState.Account;\n        const accessTokens = oldState.AccessToken ? this.mergeRemovalsDict<SerializedAccessTokenEntity>(oldState.AccessToken, newState.AccessToken) : oldState.AccessToken;\n        const refreshTokens = oldState.RefreshToken ? this.mergeRemovalsDict<SerializedRefreshTokenEntity>(oldState.RefreshToken, newState.RefreshToken) : oldState.RefreshToken;\n        const idTokens = oldState.IdToken ? this.mergeRemovalsDict<SerializedIdTokenEntity>(oldState.IdToken, newState.IdToken) : oldState.IdToken;\n        const appMetadata = oldState.AppMetadata ? this.mergeRemovalsDict<SerializedAppMetadataEntity>(oldState.AppMetadata, newState.AppMetadata) : oldState.AppMetadata;\n\n        return {\n            ...oldState,\n            Account: accounts,\n            AccessToken: accessTokens,\n            RefreshToken: refreshTokens,\n            IdToken: idTokens,\n            AppMetadata: appMetadata\n        };\n    }\n\n    /**\n     * Helper to merge new cache with the old one\n     * @param oldState - cache before changes\n     * @param newState - updated cache\n     */\n    private mergeRemovalsDict<T>(oldState: Record<string, T>, newState?: Record<string, T>): Record<string, T> {\n        const finalState = { ...oldState };\n        Object.keys(oldState).forEach((oldKey) => {\n            if (!newState || !(newState.hasOwnProperty(oldKey))) {\n                delete finalState[oldKey];\n            }\n        });\n        return finalState;\n    }\n\n    /**\n     * Helper to overlay as a part of cache merge\n     * @param passedInCache - cache read from the blob\n     */\n    private overlayDefaults(passedInCache: JsonCache): JsonCache {\n        this.logger.trace(\"Overlaying input cache with the default cache\");\n        return {\n            Account: {\n                ...defaultSerializedCache.Account,\n                ...passedInCache.Account,\n            },\n            IdToken: {\n                ...defaultSerializedCache.IdToken,\n                ...passedInCache.IdToken,\n            },\n            AccessToken: {\n                ...defaultSerializedCache.AccessToken,\n                ...passedInCache.AccessToken,\n            },\n            RefreshToken: {\n                ...defaultSerializedCache.RefreshToken,\n                ...passedInCache.RefreshToken,\n            },\n            AppMetadata: {\n                ...defaultSerializedCache.AppMetadata,\n                ...passedInCache.AppMetadata,\n            },\n        };\n    }\n}\n","/* eslint-disable header/header */\nexport const name = \"@azure/msal-node\";\nexport const version = \"1.15.0\";\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { AuthError } from \"@azure/msal-common\";\n\n/**\n * NodeAuthErrorMessage class containing string constants used by error codes and messages.\n */\nexport const NodeAuthErrorMessage = {\n    invalidLoopbackAddressType: {\n        code: \"invalid_loopback_server_address_type\",\n        desc: \"Loopback server address is not type string. This is unexpected.\"\n    },\n    unableToLoadRedirectUri: {\n        code: \"unable_to_load_redirectUrl\",\n        desc: \"Loopback server callback was invoked without a url. This is unexpected.\"\n    },\n    noAuthCodeInResponse: {\n        code: \"no_auth_code_in_response\",\n        desc: \"No auth code found in the server response. Please check your network trace to determine what happened.\"\n    },\n    noLoopbackServerExists: {\n        code: \"no_loopback_server_exists\",\n        desc: \"No loopback server exists yet.\"\n    },\n    loopbackServerAlreadyExists: {\n        code: \"loopback_server_already_exists\",\n        desc: \"Loopback server already exists. Cannot create another.\"\n    },\n    loopbackServerTimeout: {\n        code: \"loopback_server_timeout\",\n        desc: \"Timed out waiting for auth code listener to be registered.\"\n    },\n    stateNotFoundError: {\n        code: \"state_not_found\",\n        desc: \"State not found. Please verify that the request originated from msal.\"\n    },\n};\n\nexport class NodeAuthError extends AuthError {\n    constructor(errorCode: string, errorMessage?: string) {\n        super(errorCode, errorMessage);\n        this.name = \"NodeAuthError\";\n    }\n\n    /**\n     * Creates an error thrown if loopback server address is of type string.\n     */\n    static createInvalidLoopbackAddressTypeError(): NodeAuthError {\n        return new NodeAuthError(NodeAuthErrorMessage.invalidLoopbackAddressType.code,\n            `${NodeAuthErrorMessage.invalidLoopbackAddressType.desc}`);\n    }\n\n    /**\n     * Creates an error thrown if the loopback server is unable to get a url.\n     */\n    static createUnableToLoadRedirectUrlError(): NodeAuthError {\n        return new NodeAuthError(NodeAuthErrorMessage.unableToLoadRedirectUri.code,\n            `${NodeAuthErrorMessage.unableToLoadRedirectUri.desc}`);\n    }\n\n    /**\n     * Creates an error thrown if the server response does not contain an auth code.\n     */\n    static createNoAuthCodeInResponseError(): NodeAuthError {\n        return new NodeAuthError(NodeAuthErrorMessage.noAuthCodeInResponse.code,\n            `${NodeAuthErrorMessage.noAuthCodeInResponse.desc}`);\n    }\n\n    /**\n     * Creates an error thrown if the loopback server has not been spun up yet.\n     */\n    static createNoLoopbackServerExistsError(): NodeAuthError {\n        return new NodeAuthError(NodeAuthErrorMessage.noLoopbackServerExists.code,\n            `${NodeAuthErrorMessage.noLoopbackServerExists.desc}`);\n    }\n\n    /**\n     * Creates an error thrown if a loopback server already exists when attempting to create another one.\n     */\n    static createLoopbackServerAlreadyExistsError(): NodeAuthError {\n        return new NodeAuthError(NodeAuthErrorMessage.loopbackServerAlreadyExists.code,\n            `${NodeAuthErrorMessage.loopbackServerAlreadyExists.desc}`);\n    }\n\n    /**\n     * Creates an error thrown if the loopback server times out registering the auth code listener.\n     */\n    static createLoopbackServerTimeoutError(): NodeAuthError {\n        return new NodeAuthError(NodeAuthErrorMessage.loopbackServerTimeout.code,\n            `${NodeAuthErrorMessage.loopbackServerTimeout.desc}`);\n    }\n\n    /**\n     * Creates an error thrown when the state is not present.\n     */\n    static createStateNotFoundError(): NodeAuthError {\n        return new NodeAuthError(NodeAuthErrorMessage.stateNotFoundError.code, NodeAuthErrorMessage.stateNotFoundError.desc);\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AuthorizationCodeClient,\n    ClientConfiguration,\n    RefreshTokenClient,\n    AuthenticationResult,\n    Authority,\n    AuthorityFactory,\n    BaseAuthRequest,\n    SilentFlowClient,\n    Logger,\n    ServerTelemetryManager,\n    ServerTelemetryRequest,\n    CommonSilentFlowRequest,\n    CommonRefreshTokenRequest,\n    CommonAuthorizationCodeRequest,\n    CommonAuthorizationUrlRequest,\n    CommonUsernamePasswordRequest,\n    UsernamePasswordClient,\n    AuthenticationScheme,\n    ResponseMode,\n    AuthorityOptions,\n    OIDC_DEFAULT_SCOPES,\n    AzureRegionConfiguration,\n    AuthError,\n    AzureCloudOptions,\n    AuthorizationCodePayload,\n    StringUtils,\n    ClientAuthError,\n    Constants, } from \"@azure/msal-common\";\nimport { Configuration, buildAppConfiguration, NodeConfiguration } from \"../config/Configuration\";\nimport { CryptoProvider } from \"../crypto/CryptoProvider\";\nimport { NodeStorage } from \"../cache/NodeStorage\";\nimport { Constants as NodeConstants, ApiId } from \"../utils/Constants\";\nimport { TokenCache } from \"../cache/TokenCache\";\nimport { ClientAssertion } from \"./ClientAssertion\";\nimport { AuthorizationUrlRequest } from \"../request/AuthorizationUrlRequest\";\nimport { AuthorizationCodeRequest } from \"../request/AuthorizationCodeRequest\";\nimport { RefreshTokenRequest } from \"../request/RefreshTokenRequest\";\nimport { SilentFlowRequest } from \"../request/SilentFlowRequest\";\nimport { version, name } from \"../packageMetadata\";\nimport { UsernamePasswordRequest } from \"../request/UsernamePasswordRequest\";\nimport { NodeAuthError } from \"../error/NodeAuthError\";\n\n/**\n * Base abstract class for all ClientApplications - public and confidential\n * @public\n */\nexport abstract class ClientApplication {\n\n    protected readonly cryptoProvider: CryptoProvider;\n    private tokenCache: TokenCache;\n\n    /**\n     * Platform storage object\n     */\n    protected storage: NodeStorage;\n    /**\n     * Logger object to log the application flow\n     */\n    protected logger: Logger;\n    /**\n     * Platform configuration initialized by the application\n     */\n    protected config: NodeConfiguration;\n    /**\n     * Client assertion passed by the user for confidential client flows\n     */\n    protected clientAssertion: ClientAssertion;\n    /**\n     * Client secret passed by the user for confidential client flows\n     */\n    protected clientSecret: string;\n\n    /**\n     * Constructor for the ClientApplication\n     */\n    protected constructor(configuration: Configuration) {\n        this.config = buildAppConfiguration(configuration);\n        this.cryptoProvider = new CryptoProvider();\n        this.logger = new Logger(this.config.system.loggerOptions, name, version);\n        this.storage = new NodeStorage(this.logger, this.config.auth.clientId, this.cryptoProvider);\n        this.tokenCache = new TokenCache(\n            this.storage,\n            this.logger,\n            this.config.cache.cachePlugin\n        );\n    }\n\n    /**\n     * Creates the URL of the authorization request, letting the user input credentials and consent to the\n     * application. The URL targets the /authorize endpoint of the authority configured in the\n     * application object.\n     *\n     * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI\n     * sent in the request and should contain an authorization code, which can then be used to acquire tokens via\n     * `acquireTokenByCode(AuthorizationCodeRequest)`.\n     */\n    async getAuthCodeUrl(request: AuthorizationUrlRequest): Promise<string> {\n        this.logger.info(\"getAuthCodeUrl called\", request.correlationId);\n        const validRequest: CommonAuthorizationUrlRequest = {\n            ...request,\n            ... await this.initializeBaseRequest(request),\n            responseMode: request.responseMode || ResponseMode.QUERY,\n            authenticationScheme: AuthenticationScheme.BEARER\n        };\n\n        const authClientConfig = await this.buildOauthClientConfiguration(\n            validRequest.authority,\n            validRequest.correlationId,\n            undefined,\n            undefined,\n            request.azureCloudOptions\n        );\n        const authorizationCodeClient = new AuthorizationCodeClient(\n            authClientConfig\n        );\n        this.logger.verbose(\"Auth code client created\", validRequest.correlationId);\n        return authorizationCodeClient.getAuthCodeUrl(validRequest);\n    }\n\n    /**\n     * Acquires a token by exchanging the Authorization Code received from the first step of OAuth2.0\n     * Authorization Code flow.\n     *\n     * `getAuthCodeUrl(AuthorizationCodeUrlRequest)` can be used to create the URL for the first step of OAuth2.0\n     * Authorization Code flow. Ensure that values for redirectUri and scopes in AuthorizationCodeUrlRequest and\n     * AuthorizationCodeRequest are the same.\n     */\n    async acquireTokenByCode(request: AuthorizationCodeRequest, authCodePayLoad?: AuthorizationCodePayload): Promise<AuthenticationResult> {\n        this.logger.info(\"acquireTokenByCode called\");\n        if (request.state && authCodePayLoad){\n            this.logger.info(\"acquireTokenByCode - validating state\");\n            this.validateState(request.state, authCodePayLoad.state || \"\");\n            // eslint-disable-next-line no-param-reassign\n            authCodePayLoad= {...authCodePayLoad, state: \"\"};\n        }\n        const validRequest: CommonAuthorizationCodeRequest = {\n            ...request,\n            ... await this.initializeBaseRequest(request),\n            authenticationScheme: AuthenticationScheme.BEARER\n        };\n\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByCode, validRequest.correlationId);\n        try {\n            const authClientConfig = await this.buildOauthClientConfiguration(\n                validRequest.authority,\n                validRequest.correlationId,\n                serverTelemetryManager,\n                undefined,\n                request.azureCloudOptions\n            );\n            const authorizationCodeClient = new AuthorizationCodeClient(\n                authClientConfig\n            );\n            this.logger.verbose(\"Auth code client created\", validRequest.correlationId);\n            return authorizationCodeClient.acquireToken(validRequest, authCodePayLoad);\n        } catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(validRequest.correlationId);\n            }\n            serverTelemetryManager.cacheFailedRequest(e);\n            throw e;\n        }\n    }\n\n    /**\n     * Acquires a token by exchanging the refresh token provided for a new set of tokens.\n     *\n     * This API is provided only for scenarios where you would like to migrate from ADAL to MSAL. Otherwise, it is\n     * recommended that you use `acquireTokenSilent()` for silent scenarios. When using `acquireTokenSilent()`, MSAL will\n     * handle the caching and refreshing of tokens automatically.\n     */\n    async acquireTokenByRefreshToken(request: RefreshTokenRequest): Promise<AuthenticationResult | null> {\n        this.logger.info(\"acquireTokenByRefreshToken called\", request.correlationId);\n        const validRequest: CommonRefreshTokenRequest = {\n            ...request,\n            ... await this.initializeBaseRequest(request),\n            authenticationScheme: AuthenticationScheme.BEARER\n        };\n\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByRefreshToken, validRequest.correlationId);\n        try {\n            const refreshTokenClientConfig = await this.buildOauthClientConfiguration(\n                validRequest.authority,\n                validRequest.correlationId,\n                serverTelemetryManager,\n                undefined,\n                request.azureCloudOptions\n            );\n            const refreshTokenClient = new RefreshTokenClient(\n                refreshTokenClientConfig\n            );\n            this.logger.verbose(\"Refresh token client created\", validRequest.correlationId);\n            return refreshTokenClient.acquireToken(validRequest);\n        } catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(validRequest.correlationId);\n            }\n            serverTelemetryManager.cacheFailedRequest(e);\n            throw e;\n        }\n    }\n\n    /**\n     * Acquires a token silently when a user specifies the account the token is requested for.\n     *\n     * This API expects the user to provide an account object and looks into the cache to retrieve the token if present.\n     * There is also an optional \"forceRefresh\" boolean the user can send to bypass the cache for access_token and id_token.\n     * In case the refresh_token is expired or not found, an error is thrown\n     * and the guidance is for the user to call any interactive token acquisition API (eg: `acquireTokenByCode()`).\n     */\n    async acquireTokenSilent(request: SilentFlowRequest): Promise<AuthenticationResult | null> {\n        const validRequest: CommonSilentFlowRequest = {\n            ...request,\n            ... await this.initializeBaseRequest(request),\n            forceRefresh: request.forceRefresh || false\n        };\n\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenSilent, validRequest.correlationId, validRequest.forceRefresh);\n        try {\n            const silentFlowClientConfig = await this.buildOauthClientConfiguration(\n                validRequest.authority,\n                validRequest.correlationId,\n                serverTelemetryManager,\n                undefined,\n                request.azureCloudOptions\n            );\n            const silentFlowClient = new SilentFlowClient(\n                silentFlowClientConfig\n            );\n            this.logger.verbose(\"Silent flow client created\", validRequest.correlationId);\n            return silentFlowClient.acquireToken(validRequest);\n        } catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(validRequest.correlationId);\n            }\n            serverTelemetryManager.cacheFailedRequest(e);\n            throw e;\n        }\n    }\n\n    /**\n     * Acquires tokens with password grant by exchanging client applications username and password for credentials\n     *\n     * The latest OAuth 2.0 Security Best Current Practice disallows the password grant entirely.\n     * More details on this recommendation at https://tools.ietf.org/html/draft-ietf-oauth-security-topics-13#section-3.4\n     * Microsoft's documentation and recommendations are at:\n     * https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-authentication-flows#usernamepassword\n     *\n     * @param request - UsenamePasswordRequest\n     */\n    async acquireTokenByUsernamePassword(request: UsernamePasswordRequest): Promise<AuthenticationResult | null> {\n        this.logger.info(\"acquireTokenByUsernamePassword called\", request.correlationId);\n        const validRequest: CommonUsernamePasswordRequest = {\n            ...request,\n            ... await this.initializeBaseRequest(request)\n        };\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByUsernamePassword, validRequest.correlationId);\n        try {\n            const usernamePasswordClientConfig = await this.buildOauthClientConfiguration(\n                validRequest.authority,\n                validRequest.correlationId,\n                serverTelemetryManager,\n                undefined,\n                request.azureCloudOptions\n            );\n            const usernamePasswordClient = new UsernamePasswordClient(usernamePasswordClientConfig);\n            this.logger.verbose(\"Username password client created\", validRequest.correlationId);\n            return usernamePasswordClient.acquireToken(validRequest);\n        } catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(validRequest.correlationId);\n            }\n            serverTelemetryManager.cacheFailedRequest(e);\n            throw e;\n        }\n    }\n\n    /**\n     * Gets the token cache for the application.\n     */\n    getTokenCache(): TokenCache {\n        this.logger.info(\"getTokenCache called\");\n        return this.tokenCache;\n    }\n\n    /**\n     * Validates OIDC state by comparing the user cached state with the state received from the server.\n     * \n     * This API is provided for scenarios where you would use OAuth2.0 state parameter to mitigate against\n     * CSRF attacks.\n     * For more information about state, visit https://datatracker.ietf.org/doc/html/rfc6819#section-3.6.\n     * @param state\n     * @param cachedState\n     */\n    protected validateState(state: string, cachedState: string): void {\n        if(!state) {\n            throw NodeAuthError.createStateNotFoundError();\n        }\n\n        if(state !== cachedState) {\n            throw ClientAuthError.createStateMismatchError();\n        }\n    }\n\n    /**\n     * Returns the logger instance\n     */\n    getLogger(): Logger {\n        return this.logger;\n    }\n\n    /**\n     * Replaces the default logger set in configurations with new Logger with new configurations\n     * @param logger - Logger instance\n     */\n    setLogger(logger: Logger): void {\n        this.logger = logger;\n    }\n\n    /**\n     * Builds the common configuration to be passed to the common component based on the platform configurarion\n     * @param authority - user passed authority in configuration\n     * @param serverTelemetryManager - initializes servertelemetry if passed\n     */\n    protected async buildOauthClientConfiguration(\n        authority: string,\n        requestCorrelationId?: string, \n        serverTelemetryManager?: ServerTelemetryManager,\n        azureRegionConfiguration?: AzureRegionConfiguration, \n        azureCloudOptions?: AzureCloudOptions): Promise<ClientConfiguration> {\n        \n        this.logger.verbose(\"buildOauthClientConfiguration called\", requestCorrelationId);\n\n        // precedence - azureCloudInstance + tenant >> authority and request  >> config\n        const userAzureCloudOptions = azureCloudOptions ? azureCloudOptions : this.config.auth.azureCloudOptions;\n\n        // using null assertion operator as we ensure that all config values have default values in buildConfiguration()\n        this.logger.verbose(`building oauth client configuration with the authority: ${authority}`, requestCorrelationId);\n        const discoveredAuthority = await this.createAuthority(authority, azureRegionConfiguration, requestCorrelationId, userAzureCloudOptions);\n\n        serverTelemetryManager?.updateRegionDiscoveryMetadata(discoveredAuthority.regionDiscoveryMetadata);\n\n        const clientConfiguration: ClientConfiguration = {\n            authOptions: {\n                clientId: this.config.auth.clientId,\n                authority: discoveredAuthority,\n                clientCapabilities: this.config.auth.clientCapabilities\n            },\n            loggerOptions: {\n                logLevel: this.config.system.loggerOptions.logLevel ,\n                loggerCallback: this.config.system.loggerOptions.loggerCallback ,\n                piiLoggingEnabled: this.config.system.loggerOptions.piiLoggingEnabled ,\n                correlationId: requestCorrelationId\n            },\n            cryptoInterface: this.cryptoProvider,\n            networkInterface: this.config.system.networkClient,\n            storageInterface: this.storage,\n            serverTelemetryManager: serverTelemetryManager,\n            clientCredentials: {\n                clientSecret: this.clientSecret,\n                clientAssertion: this.clientAssertion ? this.getClientAssertion(discoveredAuthority) : undefined,\n            },\n            libraryInfo: {\n                sku: NodeConstants.MSAL_SKU,\n                version: version,\n                cpu: process.arch || Constants.EMPTY_STRING,\n                os: process.platform || Constants.EMPTY_STRING,\n            },\n            telemetry: this.config.telemetry,\n            persistencePlugin: this.config.cache.cachePlugin,\n            serializableCache: this.tokenCache            \n        };\n\n        return clientConfiguration;\n    }\n\n    private getClientAssertion(authority: Authority): { assertion: string, assertionType: string } {\n        return {\n            assertion: this.clientAssertion.getJwt(this.cryptoProvider, this.config.auth.clientId, authority.tokenEndpoint),\n            assertionType: NodeConstants.JWT_BEARER_ASSERTION_TYPE\n        };\n    }\n\n    /**\n     * Generates a request with the default scopes & generates a correlationId.\n     * @param authRequest - BaseAuthRequest for initialization\n     */\n    protected async initializeBaseRequest(authRequest: Partial<BaseAuthRequest>): Promise<BaseAuthRequest> {\n        this.logger.verbose(\"initializeRequestScopes called\", authRequest.correlationId);\n        // Default authenticationScheme to Bearer, log that POP isn't supported yet\n        if (authRequest.authenticationScheme && authRequest.authenticationScheme === AuthenticationScheme.POP) {\n            this.logger.verbose(\"Authentication Scheme 'pop' is not supported yet, setting Authentication Scheme to 'Bearer' for request\", authRequest.correlationId);\n        }\n\n        authRequest.authenticationScheme = AuthenticationScheme.BEARER;\n\n        // Set requested claims hash if claims were requested\n        if (authRequest.claims && !StringUtils.isEmpty(authRequest.claims)) {\n            authRequest.requestedClaimsHash = await this.cryptoProvider.hashString(authRequest.claims);\n        }\n\n        return {\n            ...authRequest,\n            scopes: [...((authRequest && authRequest.scopes) || []), ...OIDC_DEFAULT_SCOPES],\n            correlationId: authRequest && authRequest.correlationId || this.cryptoProvider.createNewGuid(),\n            authority: authRequest.authority || this.config.auth.authority\n        };\n    }\n\n    /**\n     * Initializes the server telemetry payload\n     * @param apiId - Id for a specific request\n     * @param correlationId - GUID\n     * @param forceRefresh - boolean to indicate network call\n     */\n    protected initializeServerTelemetryManager(apiId: number, correlationId: string, forceRefresh?: boolean): ServerTelemetryManager {\n        const telemetryPayload: ServerTelemetryRequest = {\n            clientId: this.config.auth.clientId,\n            correlationId: correlationId,\n            apiId: apiId,\n            forceRefresh: forceRefresh || false\n        };\n\n        return new ServerTelemetryManager(telemetryPayload, this.storage);\n    }\n\n    /**\n     * Create authority instance. If authority not passed in request, default to authority set on the application\n     * object. If no authority set in application object, then default to common authority.\n     * @param authorityString - authority from user configuration\n     */\n    private async createAuthority(authorityString: string, azureRegionConfiguration?: AzureRegionConfiguration, requestCorrelationId?: string, azureCloudOptions?: AzureCloudOptions): Promise<Authority> {\n        this.logger.verbose(\"createAuthority called\", requestCorrelationId);\n\n        // build authority string based on auth params - azureCloudInstance is prioritized if provided\n        const authorityUrl = Authority.generateAuthority(authorityString, azureCloudOptions);\n\n        const authorityOptions: AuthorityOptions = {\n            protocolMode: this.config.auth.protocolMode,\n            knownAuthorities: this.config.auth.knownAuthorities,\n            cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,\n            authorityMetadata: this.config.auth.authorityMetadata,\n            azureRegionConfiguration,\n            skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache,\n        };\n\n        return await AuthorityFactory.createDiscoveredInstance(authorityUrl, this.config.system.networkClient, this.storage, authorityOptions, this.logger);\n    }\n\n    /**\n     * Clear the cache\n     */\n    clearCache(): void {\n        this.storage.clear();\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { Constants as CommonConstants, ServerAuthorizationCodeResponse, UrlString } from \"@azure/msal-common\";\nimport { createServer, IncomingMessage, Server, ServerResponse } from \"http\";\nimport { NodeAuthError } from \"../error/NodeAuthError\";\nimport { Constants, HttpStatus, LOOPBACK_SERVER_CONSTANTS } from \"../utils/Constants\";\n\nexport class LoopbackClient {\n    private server: Server;\n\n    /**\n     * Spins up a loopback server which returns the server response when the localhost redirectUri is hit\n     * @param successTemplate \n     * @param errorTemplate \n     * @returns \n     */\n    async listenForAuthCode(successTemplate?: string, errorTemplate?: string): Promise<ServerAuthorizationCodeResponse> {\n        if (!!this.server) {\n            throw NodeAuthError.createLoopbackServerAlreadyExistsError();\n        }\n\n        const authCodeListener = new Promise<ServerAuthorizationCodeResponse>((resolve, reject) => {\n            this.server = createServer(async (req: IncomingMessage, res: ServerResponse) => {\n                const url = req.url;\n                if (!url) {\n                    res.end(errorTemplate || \"Error occurred loading redirectUrl\");\n                    reject(NodeAuthError.createUnableToLoadRedirectUrlError());\n                    return;\n                } else if (url === CommonConstants.FORWARD_SLASH) {\n                    res.end(successTemplate || \"Auth code was successfully acquired. You can close this window now.\");\n                    return;\n                }\n    \n                const authCodeResponse = UrlString.getDeserializedQueryString(url);\n                if (authCodeResponse.code) {\n                    const redirectUri = await this.getRedirectUri();\n                    res.writeHead(HttpStatus.REDIRECT, { location: redirectUri }); // Prevent auth code from being saved in the browser history\n                    res.end();\n                }\n                resolve(authCodeResponse);\n            });\n            this.server.listen(0); // Listen on any available port\n        });\n\n        // Wait for server to be listening\n        await new Promise<void>((resolve) => {\n            let ticks = 0;\n            const id = setInterval(() => {\n                if ((LOOPBACK_SERVER_CONSTANTS.TIMEOUT_MS / LOOPBACK_SERVER_CONSTANTS.INTERVAL_MS) < ticks) {\n                    throw NodeAuthError.createLoopbackServerTimeoutError();\n                }\n                \n                if (this.server.listening) {\n                    clearInterval(id);\n                    resolve();\n                }\n                ticks++;\n            }, LOOPBACK_SERVER_CONSTANTS.INTERVAL_MS);\n        });\n\n        return authCodeListener;\n    }\n\n    /**\n     * Get the port that the loopback server is running on\n     * @returns \n     */\n    getRedirectUri(): string {\n        if (!this.server) {\n            throw NodeAuthError.createNoLoopbackServerExistsError();\n        }\n                \n        const address = this.server.address();\n        if (!address || typeof address === \"string\" || !address.port) {\n            this.closeServer();\n            throw NodeAuthError.createInvalidLoopbackAddressTypeError();\n        } \n\n        const port = address && address.port;\n\n        return `${Constants.HTTP_PROTOCOL}${Constants.LOCALHOST}:${port}`;\n    }\n\n    /**\n     * Close the loopback server\n     */\n    closeServer(): void {\n        if (!!this.server) {\n            this.server.close();\n        }\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { ApiId } from \"../utils/Constants\";\nimport {\n    DeviceCodeClient,\n    AuthenticationResult,\n    CommonDeviceCodeRequest,\n    AuthError,\n    ResponseMode,\n    OIDC_DEFAULT_SCOPES,\n    CodeChallengeMethodValues,\n    Constants as CommonConstants,\n    ServerError\n} from \"@azure/msal-common\";\nimport { Configuration } from \"../config/Configuration\";\nimport { ClientApplication } from \"./ClientApplication\";\nimport { IPublicClientApplication } from \"./IPublicClientApplication\";\nimport { DeviceCodeRequest } from \"../request/DeviceCodeRequest\";\nimport { AuthorizationUrlRequest } from \"../request/AuthorizationUrlRequest\";\nimport { AuthorizationCodeRequest } from \"../request/AuthorizationCodeRequest\";\nimport { InteractiveRequest } from \"../request/InteractiveRequest\";\nimport { NodeAuthError } from \"../error/NodeAuthError\";\nimport { LoopbackClient } from \"../network/LoopbackClient\";\n\n/**\n * This class is to be used to acquire tokens for public client applications (desktop, mobile). Public client applications\n * are not trusted to safely store application secrets, and therefore can only request tokens in the name of an user.\n * @public\n */\nexport class PublicClientApplication extends ClientApplication implements IPublicClientApplication {\n    /**\n     * Important attributes in the Configuration object for auth are:\n     * - clientID: the application ID of your application. You can obtain one by registering your application with our Application registration portal.\n     * - authority: the authority URL for your application.\n     *\n     * AAD authorities are of the form https://login.microsoftonline.com/\\{Enter_the_Tenant_Info_Here\\}.\n     * - If your application supports Accounts in one organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).\n     * - If your application supports Accounts in any organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with organizations.\n     * - If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace \"Enter_the_Tenant_Info_Here\" value with common.\n     * - To restrict support to Personal Microsoft accounts only, replace \"Enter_the_Tenant_Info_Here\" value with consumers.\n     *\n     * Azure B2C authorities are of the form https://\\{instance\\}/\\{tenant\\}/\\{policy\\}. Each policy is considered\n     * its own authority. You will have to set the all of the knownAuthorities at the time of the client application\n     * construction.\n     *\n     * ADFS authorities are of the form https://\\{instance\\}/adfs.\n     */\n    constructor(configuration: Configuration) {\n        super(configuration);\n    }\n\n    /**\n     * Acquires a token from the authority using OAuth2.0 device code flow.\n     * This flow is designed for devices that do not have access to a browser or have input constraints.\n     * The authorization server issues a DeviceCode object with a verification code, an end-user code,\n     * and the end-user verification URI. The DeviceCode object is provided through a callback, and the end-user should be\n     * instructed to use another device to navigate to the verification URI to input credentials.\n     * Since the client cannot receive incoming requests, it polls the authorization server repeatedly\n     * until the end-user completes input of credentials.\n     */\n    public async acquireTokenByDeviceCode(request: DeviceCodeRequest): Promise<AuthenticationResult | null> {\n        this.logger.info(\"acquireTokenByDeviceCode called\", request.correlationId);\n        const validRequest: CommonDeviceCodeRequest = Object.assign(request,  await this.initializeBaseRequest(request));\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByDeviceCode, validRequest.correlationId);\n        try {\n            const deviceCodeConfig = await this.buildOauthClientConfiguration(\n                validRequest.authority,\n                validRequest.correlationId,\n                serverTelemetryManager,\n                undefined,\n                request.azureCloudOptions\n            );\n            const deviceCodeClient = new DeviceCodeClient(deviceCodeConfig);\n            this.logger.verbose(\"Device code client created\", validRequest.correlationId);\n            return deviceCodeClient.acquireToken(validRequest);\n        } catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(validRequest.correlationId);\n            }\n            serverTelemetryManager.cacheFailedRequest(e);\n            throw e;\n        }\n    }\n\n    /**\n     * Acquires a token by requesting an Authorization code then exchanging it for a token.\n     */\n    async acquireTokenInteractive(request: InteractiveRequest): Promise<AuthenticationResult> {\n        const { verifier, challenge } = await this.cryptoProvider.generatePkceCodes();\n        const { openBrowser, successTemplate, errorTemplate, ...remainingProperties } = request;\n\n        const loopbackClient = new LoopbackClient();\n        const authCodeListener = loopbackClient.listenForAuthCode(successTemplate, errorTemplate);\n        const redirectUri = loopbackClient.getRedirectUri();\n\n        const validRequest: AuthorizationUrlRequest = {\n            ...remainingProperties,\n            scopes: request.scopes || OIDC_DEFAULT_SCOPES,\n            redirectUri: redirectUri,\n            responseMode: ResponseMode.QUERY,\n            codeChallenge: challenge, \n            codeChallengeMethod: CodeChallengeMethodValues.S256\n        };\n\n        const authCodeUrl = await this.getAuthCodeUrl(validRequest);\n        await openBrowser(authCodeUrl);\n        const authCodeResponse = await authCodeListener.finally(() => {\n            loopbackClient.closeServer();\n        });\n\n        if (authCodeResponse.error) {\n            throw new ServerError(authCodeResponse.error, authCodeResponse.error_description, authCodeResponse.suberror);\n        } else if (!authCodeResponse.code) {\n            throw NodeAuthError.createNoAuthCodeInResponseError();\n        }\n\n        const clientInfo = authCodeResponse.client_info;\n        const tokenRequest: AuthorizationCodeRequest = {\n            code: authCodeResponse.code,\n            codeVerifier: verifier,\n            clientInfo: clientInfo || CommonConstants.EMPTY_STRING,\n            ...validRequest\n        };\n        return this.acquireTokenByCode(tokenRequest);\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { JwtHeader, sign } from \"jsonwebtoken\";\nimport { TimeUtils, ClientAuthError, Constants } from \"@azure/msal-common\";\nimport { CryptoProvider } from \"../crypto/CryptoProvider\";\nimport { EncodingUtils } from \"../utils/EncodingUtils\";\nimport { JwtConstants } from \"../utils/Constants\";\n\n/**\n * Client assertion of type jwt-bearer used in confidential client flows\n * @public\n */\nexport class ClientAssertion {\n\n    private jwt: string;\n    private privateKey: string;\n    private thumbprint: string;\n    private expirationTime: number;\n    private issuer: string;\n    private jwtAudience: string;\n    private publicCertificate: Array<string>;\n\n    /**\n     * Initialize the ClientAssertion class from the clientAssertion passed by the user\n     * @param assertion - refer https://tools.ietf.org/html/rfc7521\n     */\n    public static fromAssertion(assertion: string): ClientAssertion {\n        const clientAssertion = new ClientAssertion();\n        clientAssertion.jwt = assertion;\n        return clientAssertion;\n    }\n\n    /**\n     * Initialize the ClientAssertion class from the certificate passed by the user\n     * @param thumbprint - identifier of a certificate\n     * @param privateKey - secret key\n     * @param publicCertificate - electronic document provided to prove the ownership of the public key\n     */\n    public static fromCertificate(thumbprint: string, privateKey: string, publicCertificate?: string): ClientAssertion {\n        const clientAssertion = new ClientAssertion();\n        clientAssertion.privateKey = privateKey;\n        clientAssertion.thumbprint = thumbprint;\n        if (publicCertificate) {\n            clientAssertion.publicCertificate = this.parseCertificate(publicCertificate);\n        }\n        return clientAssertion;\n    }\n\n    /**\n     * Update JWT for certificate based clientAssertion, if passed by the user, uses it as is\n     * @param cryptoProvider - library's crypto helper\n     * @param issuer - iss claim\n     * @param jwtAudience - aud claim\n     */\n    public getJwt(cryptoProvider: CryptoProvider, issuer: string, jwtAudience: string): string {\n        // if assertion was created from certificate, check if jwt is expired and create new one.\n        if (this.privateKey && this.thumbprint) {\n\n            if (this.jwt && !this.isExpired() && issuer === this.issuer && jwtAudience === this.jwtAudience) {\n                return this.jwt;\n            }\n\n            return this.createJwt(cryptoProvider, issuer, jwtAudience);\n        }\n\n        /*\n         * if assertion was created by caller, then we just append it. It is up to the caller to\n         * ensure that it contains necessary claims and that it is not expired.\n         */\n        if (this.jwt) {\n            return this.jwt;\n        }\n\n        throw ClientAuthError.createInvalidAssertionError();\n    }\n\n    /**\n     * JWT format and required claims specified: https://tools.ietf.org/html/rfc7523#section-3\n     */\n    private createJwt(cryptoProvider: CryptoProvider, issuer: string, jwtAudience: string): string {\n\n        this.issuer = issuer;\n        this.jwtAudience = jwtAudience;\n        const issuedAt = TimeUtils.nowSeconds();\n        this.expirationTime = issuedAt + 600;\n\n        const header: JwtHeader = {\n            alg: JwtConstants.RSA_256,\n            x5t: EncodingUtils.base64EncodeUrl(this.thumbprint, \"hex\")\n        };\n\n        if (this.publicCertificate) {\n            Object.assign(header, {\n                x5c: this.publicCertificate\n            } as Partial<JwtHeader>);\n        }\n\n        const payload = {\n            [JwtConstants.AUDIENCE]: this.jwtAudience,\n            [JwtConstants.EXPIRATION_TIME]: this.expirationTime,\n            [JwtConstants.ISSUER]: this.issuer,\n            [JwtConstants.SUBJECT]: this.issuer,\n            [JwtConstants.NOT_BEFORE]: issuedAt,\n            [JwtConstants.JWT_ID]: cryptoProvider.createNewGuid()\n        };\n\n        this.jwt = sign(payload, this.privateKey, { header });\n        return this.jwt;\n    }\n\n    /**\n     * Utility API to check expiration\n     */\n    private isExpired(): boolean {\n        return this.expirationTime < TimeUtils.nowSeconds();\n    }\n\n    /**\n     * Extracts the raw certs from a given certificate string and returns them in an array.\n     * @param publicCertificate - electronic document provided to prove the ownership of the public key\n     */\n    public static parseCertificate(publicCertificate: string): Array<string> {\n        /**\n         * This is regex to identify the certs in a given certificate string.\n         * We want to look for the contents between the BEGIN and END certificate strings, without the associated newlines.\n         * The information in parens \"(.+?)\" is the capture group to represent the cert we want isolated.\n         * \".\" means any string character, \"+\" means match 1 or more times, and \"?\" means the shortest match.\n         * The \"g\" at the end of the regex means search the string globally, and the \"s\" enables the \".\" to match newlines.\n         */\n        const regexToFindCerts = /-----BEGIN CERTIFICATE-----\\r*\\n(.+?)\\r*\\n-----END CERTIFICATE-----/gs;\n        const certs: string[] = [];\n\n        let matches;\n        while ((matches = regexToFindCerts.exec(publicCertificate)) !== null) {\n            // matches[1] represents the first parens capture group in the regex.\n            certs.push(matches[1].replace(/\\r*\\n/g, Constants.EMPTY_STRING));\n        }\n\n        return certs;\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { ClientApplication } from \"./ClientApplication\";\nimport { Configuration } from \"../config/Configuration\";\nimport { ClientAssertion } from \"./ClientAssertion\";\nimport { Constants as NodeConstants, ApiId, REGION_ENVIRONMENT_VARIABLE } from \"../utils/Constants\";\nimport {\n    ClientCredentialClient,\n    OnBehalfOfClient,\n    CommonClientCredentialRequest,\n    CommonOnBehalfOfRequest,\n    AuthenticationResult,\n    StringUtils,\n    ClientAuthError,\n    AzureRegionConfiguration,\n    AuthError,\n    Constants,\n    IAppTokenProvider,\n    OIDC_DEFAULT_SCOPES\n} from \"@azure/msal-common\";\nimport { IConfidentialClientApplication } from \"./IConfidentialClientApplication\";\nimport { OnBehalfOfRequest } from \"../request/OnBehalfOfRequest\";\nimport { ClientCredentialRequest } from \"../request/ClientCredentialRequest\";\n\n/**\n *  This class is to be used to acquire tokens for confidential client applications (webApp, webAPI). Confidential client applications\n *  will configure application secrets, client certificates/assertions as applicable\n * @public\n */\nexport class ConfidentialClientApplication extends ClientApplication implements IConfidentialClientApplication {\n    private appTokenProvider?: IAppTokenProvider;\n\n    /**\n     * Constructor for the ConfidentialClientApplication\n     *\n     * Required attributes in the Configuration object are:\n     * - clientID: the application ID of your application. You can obtain one by registering your application with our application registration portal\n     * - authority: the authority URL for your application.\n     * - client credential: Must set either client secret, certificate, or assertion for confidential clients. You can obtain a client secret from the application registration portal.\n     *\n     * In Azure AD, authority is a URL indicating of the form https://login.microsoftonline.com/\\{Enter_the_Tenant_Info_Here\\}.\n     * If your application supports Accounts in one organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).\n     * If your application supports Accounts in any organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with organizations.\n     * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace \"Enter_the_Tenant_Info_Here\" value with common.\n     * To restrict support to Personal Microsoft accounts only, replace \"Enter_the_Tenant_Info_Here\" value with consumers.\n     *\n     * In Azure B2C, authority is of the form https://\\{instance\\}/tfp/\\{tenant\\}/\\{policyName\\}/\n     * Full B2C functionality will be available in this library in future versions.\n     *\n     * @param Configuration - configuration object for the MSAL ConfidentialClientApplication instance\n     */\n    constructor(configuration: Configuration) {\n        super(configuration);\n        this.setClientCredential(this.config);\n        this.appTokenProvider = undefined;\n    }\n\n    /**               \n     * This extensibility point only works for the client_credential flow, i.e. acquireTokenByClientCredential and\n     * is meant for Azure SDK to enhance Managed Identity support.\n     * \n     * @param IAppTokenProvider  - Extensibility interface, which allows the app developer to return a token from a custom source.     \n     */\n    SetAppTokenProvider(provider: IAppTokenProvider): void {\n        this.appTokenProvider = provider;\n    }\n\n    /**\n     * Acquires tokens from the authority for the application (not for an end user).\n     */\n    public async acquireTokenByClientCredential(request: ClientCredentialRequest): Promise<AuthenticationResult | null> {\n        this.logger.info(\"acquireTokenByClientCredential called\", request.correlationId);\n\n        // If there is a client assertion present in the request, it overrides the one present in the client configuration\n        let clientAssertion;\n        if (request.clientAssertion) {\n            clientAssertion = {\n                assertion: request.clientAssertion,\n                assertionType: NodeConstants.JWT_BEARER_ASSERTION_TYPE\n            };\n        }\n\n        const baseRequest = await this.initializeBaseRequest(request);\n\n        // valid base request should not contain oidc scopes in this grant type\n        const validBaseRequest = {\n            ...baseRequest,\n            scopes: baseRequest.scopes.filter((scope: string) => !OIDC_DEFAULT_SCOPES.includes(scope))\n        };\n\n        const validRequest: CommonClientCredentialRequest = {\n            ...request,\n            ...validBaseRequest,\n            clientAssertion\n        };\n\n        const azureRegionConfiguration: AzureRegionConfiguration = {\n            azureRegion: validRequest.azureRegion,\n            environmentRegion: process.env[REGION_ENVIRONMENT_VARIABLE]\n        };\n\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByClientCredential, validRequest.correlationId, validRequest.skipCache);\n        try {\n            const clientCredentialConfig = await this.buildOauthClientConfiguration(\n                validRequest.authority,\n                validRequest.correlationId,\n                serverTelemetryManager,\n                azureRegionConfiguration,\n                request.azureCloudOptions\n            );\n            const clientCredentialClient = new ClientCredentialClient(clientCredentialConfig, this.appTokenProvider);\n            this.logger.verbose(\"Client credential client created\", validRequest.correlationId);\n            return clientCredentialClient.acquireToken(validRequest);\n        } catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(validRequest.correlationId);\n            }\n            serverTelemetryManager.cacheFailedRequest(e);\n            throw e;\n        }\n    }\n\n    /**\n     * Acquires tokens from the authority for the application.\n     *\n     * Used in scenarios where the current app is a middle-tier service which was called with a token\n     * representing an end user. The current app can use the token (oboAssertion) to request another\n     * token to access downstream web API, on behalf of that user.\n     *\n     * The current middle-tier app has no user interaction to obtain consent.\n     * See how to gain consent upfront for your middle-tier app from this article.\n     * https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-on-behalf-of-flow#gaining-consent-for-the-middle-tier-application\n     */\n    public async acquireTokenOnBehalfOf(request: OnBehalfOfRequest): Promise<AuthenticationResult | null> {\n        this.logger.info(\"acquireTokenOnBehalfOf called\", request.correlationId);\n        const validRequest: CommonOnBehalfOfRequest = {\n            ...request,\n            ... await this.initializeBaseRequest(request)\n        };\n        try {\n            const onBehalfOfConfig = await this.buildOauthClientConfiguration(\n                validRequest.authority,\n                validRequest.correlationId,\n                undefined,\n                undefined,\n                request.azureCloudOptions\n            );\n            const oboClient = new OnBehalfOfClient(onBehalfOfConfig);\n            this.logger.verbose(\"On behalf of client created\", validRequest.correlationId);\n            return oboClient.acquireToken(validRequest);\n        } catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(validRequest.correlationId);\n            }\n            throw e;\n        }\n    }\n\n    private setClientCredential(configuration: Configuration): void {\n        const clientSecretNotEmpty = !StringUtils.isEmpty(configuration.auth.clientSecret);\n        const clientAssertionNotEmpty = !StringUtils.isEmpty(configuration.auth.clientAssertion);\n        const certificate = configuration.auth.clientCertificate || {\n            thumbprint: Constants.EMPTY_STRING,\n            privateKey: Constants.EMPTY_STRING\n        };\n        const certificateNotEmpty = !StringUtils.isEmpty(certificate.thumbprint) || !StringUtils.isEmpty(certificate.privateKey);\n\n        /*\n         * If app developer configures this callback, they don't need a credential\n         * i.e. AzureSDK can get token from Managed Identity without a cert / secret\n         */\n        if (this.appTokenProvider) {\n            return;\n        }\n\n        // Check that at most one credential is set on the application\n        if (\n            clientSecretNotEmpty && clientAssertionNotEmpty ||\n            clientAssertionNotEmpty && certificateNotEmpty ||\n            clientSecretNotEmpty && certificateNotEmpty) {\n            throw ClientAuthError.createInvalidCredentialError();\n        }\n\n        if (configuration.auth.clientSecret) {\n            this.clientSecret = configuration.auth.clientSecret;\n            return;\n        }\n\n        if (configuration.auth.clientAssertion) {\n            this.clientAssertion = ClientAssertion.fromAssertion(configuration.auth.clientAssertion);\n            return;\n        }\n\n        if (!certificateNotEmpty) {\n            throw ClientAuthError.createInvalidCredentialError();\n        } else {\n            this.clientAssertion = ClientAssertion.fromCertificate(certificate.thumbprint, certificate.privateKey, configuration.auth.clientCertificate?.x5c);\n        }\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { AccountEntity, ICachePlugin, TokenCacheContext } from \"@azure/msal-common\";\nimport { TokenCache } from \"../TokenCache\";\nimport { IPartitionManager } from \"./IPartitionManager\";\nimport { ICacheClient } from \"./ICacheClient\";\n\nexport class DistributedCachePlugin implements ICachePlugin {\n    private client: ICacheClient;\n    private partitionManager: IPartitionManager;\n\n    constructor(client: ICacheClient, partitionManager: IPartitionManager) {\n        this.client = client;\n        this.partitionManager = partitionManager;\n    }\n  \n    public async beforeCacheAccess(cacheContext: TokenCacheContext): Promise<void> {\n        const partitionKey = await this.partitionManager.getKey();\n        const cacheData = await this.client.get(partitionKey);\n        cacheContext.tokenCache.deserialize(cacheData);\n    }\n  \n    public async afterCacheAccess(cacheContext: TokenCacheContext): Promise<void> {\n        if (cacheContext.cacheHasChanged) {\n            const kvStore = (cacheContext.tokenCache as TokenCache).getKVStore();\n            const accountEntities = Object.values(kvStore).filter(value => AccountEntity.isAccountEntity(value as object));\n\n            if (accountEntities.length > 0) {\n                const accountEntity = accountEntities[0] as AccountEntity;\n                const partitionKey = await this.partitionManager.extractKey(accountEntity);\n                          \n                await this.client.set(partitionKey, cacheContext.tokenCache.serialize());           \n            }\n        }\n    }\n}\n"],"names":["HttpMethod","HttpStatus","ProxyStatus","REGION_ENVIRONMENT_VARIABLE","RANDOM_OCTET_SIZE","Hash","SHA256","CharSet","CV_CHARSET","Constants","MSAL_SKU","JWT_BEARER_ASSERTION_TYPE","AUTHORIZATION_PENDING","HTTP_PROTOCOL","LOCALHOST","ApiId","JwtConstants","ALGORITHM","RSA_256","X5T","X5C","AUDIENCE","EXPIRATION_TIME","ISSUER","SUBJECT","NOT_BEFORE","JWT_ID","LOOPBACK_SERVER_CONSTANTS","INTERVAL_MS","TIMEOUT_MS","NetworkUtils","getNetworkResponse","headers","body","statusCode","status","HttpClient","constructor","proxyUrl","customAgentOptions","sendGetRequestAsync","url","options","networkRequestViaProxy","GET","networkRequestViaHttps","sendPostRequestAsync","cancellationToken","POST","proxyUrlString","httpMethod","agentOptions","timeout","URL","destinationUrl","tunnelRequestOptions","host","hostname","port","method","path","Object","keys","length","agent","http","Agent","postRequestStringContent","outgoingRequestString","toUpperCase","href","Promise","resolve","reject","request","on","destroy","Error","end","response","socket","proxyStatusCode","SERVER_ERROR","SUCCESS_RANGE_START","SUCCESS_RANGE_END","statusMessage","setTimeout","write","data","chunk","push","dataString","Buffer","concat","toString","dataStringArray","split","httpStatusCode","parseInt","slice","join","headersArray","entries","Map","forEach","header","headerKeyValue","RegExp","headerKey","headerValue","object","JSON","parse","e","set","fromEntries","parsedHeaders","networkResponse","parseBody","isPostRequest","emptyHeaders","customOptions","https","parsedBody","error","errorType","errorDescriptionHelper","CLIENT_ERROR_RANGE_START","CLIENT_ERROR_RANGE_END","SERVER_ERROR_RANGE_START","SERVER_ERROR_RANGE_END","error_description","stringify","DEFAULT_AUTH_OPTIONS","clientId","EMPTY_STRING","authority","DEFAULT_AUTHORITY","clientSecret","clientAssertion","clientCertificate","thumbprint","privateKey","x5c","knownAuthorities","cloudDiscoveryMetadata","authorityMetadata","clientCapabilities","protocolMode","ProtocolMode","AAD","azureCloudOptions","azureCloudInstance","AzureCloudInstance","None","tenant","skipAuthorityMetadataCache","DEFAULT_CACHE_OPTIONS","DEFAULT_LOGGER_OPTIONS","loggerCallback","piiLoggingEnabled","logLevel","LogLevel","Info","DEFAULT_SYSTEM_OPTIONS","loggerOptions","networkClient","DEFAULT_TELEMETRY_OPTIONS","application","appName","appVersion","buildAppConfiguration","auth","cache","system","telemetry","systemOptions","GuidGenerator","generateGuid","uuidv4","isGuid","guid","regexGuid","test","EncodingUtils","base64Encode","str","encoding","from","base64EncodeUrl","replace","base64Decode","base64Str","base64DecodeUrl","HashUtils","sha256","buffer","crypto","createHash","update","digest","PkceGenerator","hashUtils","generatePkceCodes","verifier","generateCodeVerifier","challenge","generateCodeChallengeFromVerifier","charArr","maxNumber","byte","randomBytes","index","codeVerifier","CryptoProvider","pkceGenerator","guidGenerator","createNewGuid","input","getPublicKeyThumbprint","removeTokenBindingKey","clearKeystore","signJwt","hashString","plainText","Deserializer","deserializeJSONBlob","jsonFile","deserializedCache","StringUtils","isEmpty","deserializeAccounts","accounts","accountObjects","map","key","serializedAcc","mappedAcc","homeAccountId","home_account_id","environment","realm","localAccountId","local_account_id","username","authorityType","authority_type","name","clientInfo","client_info","lastModificationTime","last_modification_time","lastModificationApp","last_modification_app","account","AccountEntity","CacheManager","toObject","deserializeIdTokens","idTokens","idObjects","serializedIdT","mappedIdT","credentialType","credential_type","client_id","secret","idToken","IdTokenEntity","deserializeAccessTokens","accessTokens","atObjects","serializedAT","mappedAT","target","cachedAt","cached_at","expiresOn","expires_on","extendedExpiresOn","extended_expires_on","refreshOn","refresh_on","keyId","key_id","tokenType","token_type","requestedClaims","requestedClaimsHash","userAssertionHash","accessToken","AccessTokenEntity","deserializeRefreshTokens","refreshTokens","rtObjects","serializedRT","mappedRT","familyId","family_id","refreshToken","RefreshTokenEntity","deserializeAppMetadata","appMetadata","appMetadataObjects","serializedAmdt","mappedAmd","amd","AppMetadataEntity","deserializeAllCache","jsonCache","Account","IdToken","AccessToken","RefreshToken","AppMetadata","Serializer","serializeJSONBlob","serializeAccounts","accCache","accountEntity","serializeIdTokens","idTCache","idTEntity","serializeAccessTokens","atCache","atEntity","serializeRefreshTokens","rtCache","rtEntity","serializeAppMetadata","amdtCache","amdtEntity","serializeAllCache","inMemCache","NodeStorage","logger","cryptoImpl","registerChangeEmitter","func","changeEmitters","emitChange","call","cacheToInMemoryCache","inMemoryCache","inMemoryCacheToCache","getCache","getInMemoryCache","trace","setInMemoryCache","setCache","getItem","tracePii","setItem","value","getAccount","accountKey","isAccountEntity","setAccount","generateAccountKey","getIdTokenCredential","idTokenKey","isIdTokenEntity","setIdTokenCredential","generateCredentialKey","getAccessTokenCredential","accessTokenKey","isAccessTokenEntity","setAccessTokenCredential","getRefreshTokenCredential","refreshTokenKey","isRefreshTokenEntity","setRefreshTokenCredential","getAppMetadata","appMetadataKey","isAppMetadataEntity","setAppMetadata","generateAppMetadataKey","getServerTelemetry","serverTelemetrykey","serverTelemetryEntity","ServerTelemetryEntity","isServerTelemetryEntity","setServerTelemetry","serverTelemetryKey","serverTelemetry","getAuthorityMetadata","authorityMetadataEntity","AuthorityMetadataEntity","isAuthorityMetadataEntity","getAuthorityMetadataKeys","getKeys","filter","isAuthorityMetadata","setAuthorityMetadata","metadata","getThrottlingCache","throttlingCacheKey","throttlingCache","ThrottlingEntity","isThrottlingEntity","setThrottlingCache","removeItem","result","containsKey","includes","clear","cacheKeys","generateInMemoryCache","generateJsonCache","updateCredentialCacheKey","currentCacheKey","credential","updatedCacheKey","cacheItem","verbose","defaultSerializedCache","TokenCache","storage","cachePlugin","cacheHasChanged","handleChangeEvent","bind","persistence","hasChanged","serialize","finalState","cacheSnapshot","mergeState","deserialize","overlayDefaults","getKVStore","getAllAccounts","cacheContext","TokenCacheContext","beforeCacheAccess","afterCacheAccess","getAccountByHomeId","allAccounts","accountObj","getAccountByLocalId","removeAccount","generateAccountCacheKey","oldState","currentState","stateAfterRemoval","mergeRemovals","mergeUpdates","newState","newKey","newValue","hasOwnProperty","newValueNotNull","newValueIsObject","newValueIsNotArray","Array","isArray","oldStateNotUndefinedOrNull","mergeRemovalsDict","oldKey","passedInCache","version","NodeAuthErrorMessage","invalidLoopbackAddressType","code","desc","unableToLoadRedirectUri","noAuthCodeInResponse","noLoopbackServerExists","loopbackServerAlreadyExists","loopbackServerTimeout","stateNotFoundError","NodeAuthError","AuthError","errorCode","errorMessage","createInvalidLoopbackAddressTypeError","createUnableToLoadRedirectUrlError","createNoAuthCodeInResponseError","createNoLoopbackServerExistsError","createLoopbackServerAlreadyExistsError","createLoopbackServerTimeoutError","createStateNotFoundError","ClientApplication","configuration","config","cryptoProvider","Logger","tokenCache","getAuthCodeUrl","info","correlationId","validRequest","initializeBaseRequest","responseMode","ResponseMode","QUERY","authenticationScheme","AuthenticationScheme","BEARER","authClientConfig","buildOauthClientConfiguration","undefined","authorizationCodeClient","AuthorizationCodeClient","acquireTokenByCode","authCodePayLoad","state","validateState","serverTelemetryManager","initializeServerTelemetryManager","acquireToken","setCorrelationId","cacheFailedRequest","acquireTokenByRefreshToken","refreshTokenClientConfig","refreshTokenClient","RefreshTokenClient","acquireTokenSilent","forceRefresh","silentFlowClientConfig","silentFlowClient","SilentFlowClient","acquireTokenByUsernamePassword","usernamePasswordClientConfig","usernamePasswordClient","UsernamePasswordClient","getTokenCache","cachedState","ClientAuthError","createStateMismatchError","getLogger","setLogger","requestCorrelationId","azureRegionConfiguration","userAzureCloudOptions","discoveredAuthority","createAuthority","updateRegionDiscoveryMetadata","regionDiscoveryMetadata","clientConfiguration","authOptions","cryptoInterface","networkInterface","storageInterface","clientCredentials","getClientAssertion","libraryInfo","sku","NodeConstants","cpu","process","arch","os","platform","persistencePlugin","serializableCache","assertion","getJwt","tokenEndpoint","assertionType","authRequest","POP","claims","scopes","OIDC_DEFAULT_SCOPES","apiId","telemetryPayload","ServerTelemetryManager","authorityString","authorityUrl","Authority","generateAuthority","authorityOptions","AuthorityFactory","createDiscoveredInstance","clearCache","LoopbackClient","listenForAuthCode","successTemplate","errorTemplate","server","authCodeListener","createServer","req","res","CommonConstants","FORWARD_SLASH","authCodeResponse","UrlString","getDeserializedQueryString","redirectUri","getRedirectUri","writeHead","REDIRECT","location","listen","ticks","id","setInterval","listening","clearInterval","address","closeServer","close","PublicClientApplication","acquireTokenByDeviceCode","assign","deviceCodeConfig","deviceCodeClient","DeviceCodeClient","acquireTokenInteractive","openBrowser","remainingProperties","loopbackClient","codeChallenge","codeChallengeMethod","CodeChallengeMethodValues","S256","authCodeUrl","finally","ServerError","suberror","tokenRequest","ClientAssertion","fromAssertion","jwt","fromCertificate","publicCertificate","parseCertificate","issuer","jwtAudience","isExpired","createJwt","createInvalidAssertionError","issuedAt","TimeUtils","nowSeconds","expirationTime","alg","x5t","payload","sign","regexToFindCerts","certs","matches","exec","ConfidentialClientApplication","setClientCredential","appTokenProvider","SetAppTokenProvider","provider","acquireTokenByClientCredential","baseRequest","validBaseRequest","scope","azureRegion","environmentRegion","env","skipCache","clientCredentialConfig","clientCredentialClient","ClientCredentialClient","acquireTokenOnBehalfOf","onBehalfOfConfig","oboClient","OnBehalfOfClient","clientSecretNotEmpty","clientAssertionNotEmpty","certificate","certificateNotEmpty","createInvalidCredentialError","DistributedCachePlugin","client","partitionManager","partitionKey","getKey","cacheData","get","kvStore","accountEntities","values","extractKey"],"mappings":"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"}